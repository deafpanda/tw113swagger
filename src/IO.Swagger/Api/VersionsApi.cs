/* 
 * Tripwire Enterprise TE REST API User Guide & Reference
 *
 * The TE REST API allows automation of many aspects of Tripwire Enterprise
 *
 * OpenAPI spec version: 1.13.0.bmaster.r20180119190259-8b60eaa.b1753
 * Contact: support@tripwire.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IVersionsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create an element version custom property definition (since 1.9)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType CreateCustomPropertyType (CustomPropertyType body);

        /// <summary>
        /// Create an element version custom property definition (since 1.9)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> CreateCustomPropertyTypeWithHttpInfo (CustomPropertyType body);
        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5)
        /// </summary>
        /// <remarks>
        /// Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>CreateVersionRequest</returns>
        CreateVersionRequest CreateVersionRequest (CreateVersionRequest body);

        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5)
        /// </summary>
        /// <remarks>
        /// Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>ApiResponse of CreateVersionRequest</returns>
        ApiResponse<CreateVersionRequest> CreateVersionRequestWithHttpInfo (CreateVersionRequest body);
        /// <summary>
        /// Delete a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Delete an existing version custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns></returns>
        void DeleteCustomPropertyType (string rkCustomPropertyTypeId);

        /// <summary>
        /// Delete a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Delete an existing version custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCustomPropertyTypeWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Delete a single element version (since 1.6)
        /// </summary>
        /// <remarks>
        /// Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns></returns>
        void DeleteElementVersion (string rkVersionId);

        /// <summary>
        /// Delete a single element version (since 1.6)
        /// </summary>
        /// <remarks>
        /// Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteElementVersionWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Delete a custom property value from an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns></returns>
        void DeleteElementVersionCustomProperty (string rkVersionId, string propertyName);

        /// <summary>
        /// Delete a custom property value from an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteElementVersionCustomPropertyWithHttpInfo (string rkVersionId, string propertyName);
        /// <summary>
        /// Get audit event data for an element version (since 1.0)
        /// </summary>
        /// <remarks>
        /// Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>AuditInfo</returns>
        AuditInfo GetAuditDataByReadableKeyVersionId (string rkVersionId);

        /// <summary>
        /// Get audit event data for an element version (since 1.0)
        /// </summary>
        /// <remarks>
        /// Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>ApiResponse of AuditInfo</returns>
        ApiResponse<AuditInfo> GetAuditDataByReadableKeyVersionIdWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Get updated state of element version change requests (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the element version change request with current status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>CreateVersionRequest</returns>
        CreateVersionRequest GetCreateVersionRequestById (string requestId);

        /// <summary>
        /// Get updated state of element version change requests (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the element version change request with current status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>ApiResponse of CreateVersionRequest</returns>
        ApiResponse<CreateVersionRequest> GetCreateVersionRequestByIdWithHttpInfo (string requestId);
        /// <summary>
        /// Get custom property values for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>CustomProperties</returns>
        CustomProperties GetCustomProperties (string rkVersionId);

        /// <summary>
        /// Get custom property values for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>ApiResponse of CustomProperties</returns>
        ApiResponse<CustomProperties> GetCustomPropertiesWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Get a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType GetCustomPropertyTypeById (string rkCustomPropertyTypeId);

        /// <summary>
        /// Get a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> GetCustomPropertyTypeByIdWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Search custom property types (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType GetCustomPropertyTypes (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);

        /// <summary>
        /// Search custom property types (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> GetCustomPropertyTypesWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);
        /// <summary>
        /// Get element version attributes by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the attributes map for an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>ValueTypeAttribute</returns>
        ValueTypeAttribute GetElementVersionAttributes (string rkVersionId);

        /// <summary>
        /// Get element version attributes by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the attributes map for an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>ApiResponse of ValueTypeAttribute</returns>
        ApiResponse<ValueTypeAttribute> GetElementVersionAttributesWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Get element version content by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the archived content data for the given element version. Binary content is not supported.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>string</returns>
        string GetElementVersionContent (string rkVersionId, string sizeLimit = null);

        /// <summary>
        /// Get element version content by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the archived content data for the given element version. Binary content is not supported.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetElementVersionContentWithHttpInfo (string rkVersionId, string sizeLimit = null);
        /// <summary>
        /// Get element version details by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>ElementVersion</returns>
        ElementVersion GetElementVersionDetailsById (string rkVersionId);

        /// <summary>
        /// Get element version details by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        ApiResponse<ElementVersion> GetElementVersionDetailsByIdWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7)
        /// </summary>
        /// <remarks>
        /// Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ElementVersionWithAttributes</returns>
        ElementVersionWithAttributes GetElementVersionsExtract (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null);

        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7)
        /// </summary>
        /// <remarks>
        /// Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ApiResponse of ElementVersionWithAttributes</returns>
        ApiResponse<ElementVersionWithAttributes> GetElementVersionsExtractWithHttpInfo (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null);
        /// <summary>
        /// Search all element versions (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ElementVersion</returns>
        ElementVersion GetHistoricalElementVersions (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);

        /// <summary>
        /// Search all element versions (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        ApiResponse<ElementVersion> GetHistoricalElementVersionsWithHttpInfo (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);
        /// <summary>
        /// Search for latest element versions only (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ElementVersion</returns>
        ElementVersion GetLatestElementVersions (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);

        /// <summary>
        /// Search for latest element versions only (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        ApiResponse<ElementVersion> GetLatestElementVersionsWithHttpInfo (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);
        /// <summary>
        /// Get promote request status (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the promote versions request along with the completion status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>PromoteRequestCommand</returns>
        PromoteRequestCommand GetPromoteRequestById (string requestId);

        /// <summary>
        /// Get promote request status (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the promote versions request along with the completion status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>ApiResponse of PromoteRequestCommand</returns>
        ApiResponse<PromoteRequestCommand> GetPromoteRequestByIdWithHttpInfo (string requestId);
        /// <summary>
        /// Request promotion of a set of element versions (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates an asynchronous command to queue promotion of element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>PromoteRequestCommand</returns>
        PromoteRequestCommand PromoteRequest (PromoteRequestCommand body);

        /// <summary>
        /// Request promotion of a set of element versions (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates an asynchronous command to queue promotion of element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>ApiResponse of PromoteRequestCommand</returns>
        ApiResponse<PromoteRequestCommand> PromoteRequestWithHttpInfo (PromoteRequestCommand body);
        /// <summary>
        /// Set a custom property value for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns></returns>
        void SetElementVersionCustomProperty (string rkVersionId, string propertyName, PropertyValue body);

        /// <summary>
        /// Set a custom property value for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetElementVersionCustomPropertyWithHttpInfo (string rkVersionId, string propertyName, PropertyValue body);
        /// <summary>
        /// Update an existing element version custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType UpdateCustomPropertyType (CustomPropertyType body, string rkCustomPropertyTypeId);

        /// <summary>
        /// Update an existing element version custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> UpdateCustomPropertyTypeWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId);
        /// <summary>
        /// Put an update to an element version (since 1.7)
        /// </summary>
        /// <remarks>
        /// Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>ElementVersion</returns>
        ElementVersion UpdateElementVersion (string rkVersionId, ElementVersionSeverity body);

        /// <summary>
        /// Put an update to an element version (since 1.7)
        /// </summary>
        /// <remarks>
        /// Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        ApiResponse<ElementVersion> UpdateElementVersionWithHttpInfo (string rkVersionId, ElementVersionSeverity body);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Create an element version custom property definition (since 1.9)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> CreateCustomPropertyTypeAsync (CustomPropertyType body);

        /// <summary>
        /// Create an element version custom property definition (since 1.9)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> CreateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body);
        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5)
        /// </summary>
        /// <remarks>
        /// Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of CreateVersionRequest</returns>
        System.Threading.Tasks.Task<CreateVersionRequest> CreateVersionRequestAsync (CreateVersionRequest body);

        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5)
        /// </summary>
        /// <remarks>
        /// Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of ApiResponse (CreateVersionRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateVersionRequest>> CreateVersionRequestAsyncWithHttpInfo (CreateVersionRequest body);
        /// <summary>
        /// Delete a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Delete an existing version custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteCustomPropertyTypeAsync (string rkCustomPropertyTypeId);

        /// <summary>
        /// Delete a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Delete an existing version custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteCustomPropertyTypeAsyncWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Delete a single element version (since 1.6)
        /// </summary>
        /// <remarks>
        /// Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteElementVersionAsync (string rkVersionId);

        /// <summary>
        /// Delete a single element version (since 1.6)
        /// </summary>
        /// <remarks>
        /// Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteElementVersionAsyncWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Delete a custom property value from an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteElementVersionCustomPropertyAsync (string rkVersionId, string propertyName);

        /// <summary>
        /// Delete a custom property value from an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteElementVersionCustomPropertyAsyncWithHttpInfo (string rkVersionId, string propertyName);
        /// <summary>
        /// Get audit event data for an element version (since 1.0)
        /// </summary>
        /// <remarks>
        /// Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>Task of AuditInfo</returns>
        System.Threading.Tasks.Task<AuditInfo> GetAuditDataByReadableKeyVersionIdAsync (string rkVersionId);

        /// <summary>
        /// Get audit event data for an element version (since 1.0)
        /// </summary>
        /// <remarks>
        /// Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>Task of ApiResponse (AuditInfo)</returns>
        System.Threading.Tasks.Task<ApiResponse<AuditInfo>> GetAuditDataByReadableKeyVersionIdAsyncWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Get updated state of element version change requests (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the element version change request with current status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of CreateVersionRequest</returns>
        System.Threading.Tasks.Task<CreateVersionRequest> GetCreateVersionRequestByIdAsync (string requestId);

        /// <summary>
        /// Get updated state of element version change requests (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the element version change request with current status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of ApiResponse (CreateVersionRequest)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreateVersionRequest>> GetCreateVersionRequestByIdAsyncWithHttpInfo (string requestId);
        /// <summary>
        /// Get custom property values for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>Task of CustomProperties</returns>
        System.Threading.Tasks.Task<CustomProperties> GetCustomPropertiesAsync (string rkVersionId);

        /// <summary>
        /// Get custom property values for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>Task of ApiResponse (CustomProperties)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomProperties>> GetCustomPropertiesAsyncWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Get a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypeByIdAsync (string rkCustomPropertyTypeId);

        /// <summary>
        /// Get a custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypeByIdAsyncWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Search custom property types (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypesAsync (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);

        /// <summary>
        /// Search custom property types (since 1.9)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypesAsyncWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);
        /// <summary>
        /// Get element version attributes by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the attributes map for an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>Task of ValueTypeAttribute</returns>
        System.Threading.Tasks.Task<ValueTypeAttribute> GetElementVersionAttributesAsync (string rkVersionId);

        /// <summary>
        /// Get element version attributes by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the attributes map for an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>Task of ApiResponse (ValueTypeAttribute)</returns>
        System.Threading.Tasks.Task<ApiResponse<ValueTypeAttribute>> GetElementVersionAttributesAsyncWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Get element version content by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the archived content data for the given element version. Binary content is not supported.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetElementVersionContentAsync (string rkVersionId, string sizeLimit = null);

        /// <summary>
        /// Get element version content by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the archived content data for the given element version. Binary content is not supported.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetElementVersionContentAsyncWithHttpInfo (string rkVersionId, string sizeLimit = null);
        /// <summary>
        /// Get element version details by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>Task of ElementVersion</returns>
        System.Threading.Tasks.Task<ElementVersion> GetElementVersionDetailsByIdAsync (string rkVersionId);

        /// <summary>
        /// Get element version details by ID (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns an element version with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        System.Threading.Tasks.Task<ApiResponse<ElementVersion>> GetElementVersionDetailsByIdAsyncWithHttpInfo (string rkVersionId);
        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7)
        /// </summary>
        /// <remarks>
        /// Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ElementVersionWithAttributes</returns>
        System.Threading.Tasks.Task<ElementVersionWithAttributes> GetElementVersionsExtractAsync (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null);

        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7)
        /// </summary>
        /// <remarks>
        /// Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (ElementVersionWithAttributes)</returns>
        System.Threading.Tasks.Task<ApiResponse<ElementVersionWithAttributes>> GetElementVersionsExtractAsyncWithHttpInfo (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null);
        /// <summary>
        /// Search all element versions (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ElementVersion</returns>
        System.Threading.Tasks.Task<ElementVersion> GetHistoricalElementVersionsAsync (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);

        /// <summary>
        /// Search all element versions (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        System.Threading.Tasks.Task<ApiResponse<ElementVersion>> GetHistoricalElementVersionsAsyncWithHttpInfo (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);
        /// <summary>
        /// Search for latest element versions only (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ElementVersion</returns>
        System.Threading.Tasks.Task<ElementVersion> GetLatestElementVersionsAsync (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);

        /// <summary>
        /// Search for latest element versions only (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        System.Threading.Tasks.Task<ApiResponse<ElementVersion>> GetLatestElementVersionsAsyncWithHttpInfo (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null);
        /// <summary>
        /// Get promote request status (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the promote versions request along with the completion status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of PromoteRequestCommand</returns>
        System.Threading.Tasks.Task<PromoteRequestCommand> GetPromoteRequestByIdAsync (string requestId);

        /// <summary>
        /// Get promote request status (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the promote versions request along with the completion status.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of ApiResponse (PromoteRequestCommand)</returns>
        System.Threading.Tasks.Task<ApiResponse<PromoteRequestCommand>> GetPromoteRequestByIdAsyncWithHttpInfo (string requestId);
        /// <summary>
        /// Request promotion of a set of element versions (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates an asynchronous command to queue promotion of element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of PromoteRequestCommand</returns>
        System.Threading.Tasks.Task<PromoteRequestCommand> PromoteRequestAsync (PromoteRequestCommand body);

        /// <summary>
        /// Request promotion of a set of element versions (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates an asynchronous command to queue promotion of element versions.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of ApiResponse (PromoteRequestCommand)</returns>
        System.Threading.Tasks.Task<ApiResponse<PromoteRequestCommand>> PromoteRequestAsyncWithHttpInfo (PromoteRequestCommand body);
        /// <summary>
        /// Set a custom property value for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetElementVersionCustomPropertyAsync (string rkVersionId, string propertyName, PropertyValue body);

        /// <summary>
        /// Set a custom property value for an element version (since 1.9)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetElementVersionCustomPropertyAsyncWithHttpInfo (string rkVersionId, string propertyName, PropertyValue body);
        /// <summary>
        /// Update an existing element version custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> UpdateCustomPropertyTypeAsync (CustomPropertyType body, string rkCustomPropertyTypeId);

        /// <summary>
        /// Update an existing element version custom property type (since 1.9)
        /// </summary>
        /// <remarks>
        /// Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> UpdateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId);
        /// <summary>
        /// Put an update to an element version (since 1.7)
        /// </summary>
        /// <remarks>
        /// Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>Task of ElementVersion</returns>
        System.Threading.Tasks.Task<ElementVersion> UpdateElementVersionAsync (string rkVersionId, ElementVersionSeverity body);

        /// <summary>
        /// Put an update to an element version (since 1.7)
        /// </summary>
        /// <remarks>
        /// Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        System.Threading.Tasks.Task<ApiResponse<ElementVersion>> UpdateElementVersionAsyncWithHttpInfo (string rkVersionId, ElementVersionSeverity body);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class VersionsApi : IVersionsApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="VersionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public VersionsApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="VersionsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public VersionsApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Create an element version custom property definition (since 1.9) Allows creating models for custom meta-data that can be later applied to element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType CreateCustomPropertyType (CustomPropertyType body)
        {
             ApiResponse<CustomPropertyType> localVarResponse = CreateCustomPropertyTypeWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create an element version custom property definition (since 1.9) Allows creating models for custom meta-data that can be later applied to element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > CreateCustomPropertyTypeWithHttpInfo (CustomPropertyType body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->CreateCustomPropertyType");

            var localVarPath = "/versions/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Create an element version custom property definition (since 1.9) Allows creating models for custom meta-data that can be later applied to element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> CreateCustomPropertyTypeAsync (CustomPropertyType body)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await CreateCustomPropertyTypeAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create an element version custom property definition (since 1.9) Allows creating models for custom meta-data that can be later applied to element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> CreateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->CreateCustomPropertyType");

            var localVarPath = "/versions/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5) Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>CreateVersionRequest</returns>
        public CreateVersionRequest CreateVersionRequest (CreateVersionRequest body)
        {
             ApiResponse<CreateVersionRequest> localVarResponse = CreateVersionRequestWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5) Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>ApiResponse of CreateVersionRequest</returns>
        public ApiResponse< CreateVersionRequest > CreateVersionRequestWithHttpInfo (CreateVersionRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->CreateVersionRequest");

            var localVarPath = "/versions/createVersionRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateVersionRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateVersionRequest>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateVersionRequest) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateVersionRequest)));
        }

        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5) Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of CreateVersionRequest</returns>
        public async System.Threading.Tasks.Task<CreateVersionRequest> CreateVersionRequestAsync (CreateVersionRequest body)
        {
             ApiResponse<CreateVersionRequest> localVarResponse = await CreateVersionRequestAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Request processing submitted change events for External Rules (since 1.5) Queues the processing of change events for a Node and External Rule. Changes are processed by any actions and policy tests that are scoped appropriately. Processing is asynchronous. The request will return to the caller once the input has been validated. The result can be queried at /api/v1/versions/changeRequests/{rkChangeRequestId}. Version descriptions with the exists field set or defaulting to true must have one of the MD5, SHA-1, SHA-256 or SHA-512 hash attributes set. If no hash attribute is set, an MD5 hash will be computed for you based on the value of the content field, including when the content field is empty, null, or unspecified. When the exists field is set to false, then content and attributes fields must not be specified. Data submitted by the TE REST API is subject to XSS filtering. To provide literal value for the content of an element version, base64 encode the data, and submit that in the &#39;contentBase64&#39; field instead of the &#39;content&#39; field.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of ApiResponse (CreateVersionRequest)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CreateVersionRequest>> CreateVersionRequestAsyncWithHttpInfo (CreateVersionRequest body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->CreateVersionRequest");

            var localVarPath = "/versions/createVersionRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateVersionRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateVersionRequest>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateVersionRequest) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateVersionRequest)));
        }

        /// <summary>
        /// Delete a custom property type (since 1.9) Delete an existing version custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns></returns>
        public void DeleteCustomPropertyType (string rkCustomPropertyTypeId)
        {
             DeleteCustomPropertyTypeWithHttpInfo(rkCustomPropertyTypeId);
        }

        /// <summary>
        /// Delete a custom property type (since 1.9) Delete an existing version custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCustomPropertyTypeWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling VersionsApi->DeleteCustomPropertyType");

            var localVarPath = "/versions/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a custom property type (since 1.9) Delete an existing version custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteCustomPropertyTypeAsync (string rkCustomPropertyTypeId)
        {
             await DeleteCustomPropertyTypeAsyncWithHttpInfo(rkCustomPropertyTypeId);

        }

        /// <summary>
        /// Delete a custom property type (since 1.9) Delete an existing version custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a version custom property type, and the value assignments to all versions</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteCustomPropertyTypeAsyncWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling VersionsApi->DeleteCustomPropertyType");

            var localVarPath = "/versions/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a single element version (since 1.6) Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns></returns>
        public void DeleteElementVersion (string rkVersionId)
        {
             DeleteElementVersionWithHttpInfo(rkVersionId);
        }

        /// <summary>
        /// Delete a single element version (since 1.6) Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteElementVersionWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->DeleteElementVersion");

            var localVarPath = "/versions/{rkVersionId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteElementVersion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a single element version (since 1.6) Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteElementVersionAsync (string rkVersionId)
        {
             await DeleteElementVersionAsyncWithHttpInfo(rkVersionId);

        }

        /// <summary>
        /// Delete a single element version (since 1.6) Removes an element version from the TE history. It will not delete the Baseline version referenced by existing change versions, so deletion would typically be performed newest to oldest, however selective deletions are allowed.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of Element Version to fetch</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteElementVersionAsyncWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->DeleteElementVersion");

            var localVarPath = "/versions/{rkVersionId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteElementVersion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a custom property value from an element version (since 1.9) Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns></returns>
        public void DeleteElementVersionCustomProperty (string rkVersionId, string propertyName)
        {
             DeleteElementVersionCustomPropertyWithHttpInfo(rkVersionId, propertyName);
        }

        /// <summary>
        /// Delete a custom property value from an element version (since 1.9) Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteElementVersionCustomPropertyWithHttpInfo (string rkVersionId, string propertyName)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->DeleteElementVersionCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling VersionsApi->DeleteElementVersionCustomProperty");

            var localVarPath = "/versions/{rkVersionId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteElementVersionCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a custom property value from an element version (since 1.9) Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteElementVersionCustomPropertyAsync (string rkVersionId, string propertyName)
        {
             await DeleteElementVersionCustomPropertyAsyncWithHttpInfo(rkVersionId, propertyName);

        }

        /// <summary>
        /// Delete a custom property value from an element version (since 1.9) Removes the custom property assignment from the element version. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the element version. Inherited custom property values cannot be deleted and attempts to do so will result in a 404.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version</param>
        /// <param name="propertyName">Name of the element version custom property type to unassign from the version.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteElementVersionCustomPropertyAsyncWithHttpInfo (string rkVersionId, string propertyName)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->DeleteElementVersionCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling VersionsApi->DeleteElementVersionCustomProperty");

            var localVarPath = "/versions/{rkVersionId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteElementVersionCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Get audit event data for an element version (since 1.0) Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>AuditInfo</returns>
        public AuditInfo GetAuditDataByReadableKeyVersionId (string rkVersionId)
        {
             ApiResponse<AuditInfo> localVarResponse = GetAuditDataByReadableKeyVersionIdWithHttpInfo(rkVersionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get audit event data for an element version (since 1.0) Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>ApiResponse of AuditInfo</returns>
        public ApiResponse< AuditInfo > GetAuditDataByReadableKeyVersionIdWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetAuditDataByReadableKeyVersionId");

            var localVarPath = "/versions/{rkVersionId}/audit";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAuditDataByReadableKeyVersionId", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AuditInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AuditInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AuditInfo)));
        }

        /// <summary>
        /// Get audit event data for an element version (since 1.0) Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>Task of AuditInfo</returns>
        public async System.Threading.Tasks.Task<AuditInfo> GetAuditDataByReadableKeyVersionIdAsync (string rkVersionId)
        {
             ApiResponse<AuditInfo> localVarResponse = await GetAuditDataByReadableKeyVersionIdAsyncWithHttpInfo(rkVersionId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get audit event data for an element version (since 1.0) Lists all associated audit data in the form of the usernames and process names that correspond to an element version.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">rkVersionId to fetch</param>
        /// <returns>Task of ApiResponse (AuditInfo)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AuditInfo>> GetAuditDataByReadableKeyVersionIdAsyncWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetAuditDataByReadableKeyVersionId");

            var localVarPath = "/versions/{rkVersionId}/audit";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetAuditDataByReadableKeyVersionId", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AuditInfo>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AuditInfo) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(AuditInfo)));
        }

        /// <summary>
        /// Get updated state of element version change requests (since 1.5) Returns the element version change request with current status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>CreateVersionRequest</returns>
        public CreateVersionRequest GetCreateVersionRequestById (string requestId)
        {
             ApiResponse<CreateVersionRequest> localVarResponse = GetCreateVersionRequestByIdWithHttpInfo(requestId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get updated state of element version change requests (since 1.5) Returns the element version change request with current status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>ApiResponse of CreateVersionRequest</returns>
        public ApiResponse< CreateVersionRequest > GetCreateVersionRequestByIdWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling VersionsApi->GetCreateVersionRequestById");

            var localVarPath = "/versions/createVersionRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCreateVersionRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateVersionRequest>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateVersionRequest) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateVersionRequest)));
        }

        /// <summary>
        /// Get updated state of element version change requests (since 1.5) Returns the element version change request with current status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of CreateVersionRequest</returns>
        public async System.Threading.Tasks.Task<CreateVersionRequest> GetCreateVersionRequestByIdAsync (string requestId)
        {
             ApiResponse<CreateVersionRequest> localVarResponse = await GetCreateVersionRequestByIdAsyncWithHttpInfo(requestId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get updated state of element version change requests (since 1.5) Returns the element version change request with current status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of ApiResponse (CreateVersionRequest)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CreateVersionRequest>> GetCreateVersionRequestByIdAsyncWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling VersionsApi->GetCreateVersionRequestById");

            var localVarPath = "/versions/createVersionRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCreateVersionRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CreateVersionRequest>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CreateVersionRequest) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CreateVersionRequest)));
        }

        /// <summary>
        /// Get custom property values for an element version (since 1.9) Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>CustomProperties</returns>
        public CustomProperties GetCustomProperties (string rkVersionId)
        {
             ApiResponse<CustomProperties> localVarResponse = GetCustomPropertiesWithHttpInfo(rkVersionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get custom property values for an element version (since 1.9) Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>ApiResponse of CustomProperties</returns>
        public ApiResponse< CustomProperties > GetCustomPropertiesWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetCustomProperties");

            var localVarPath = "/versions/{rkVersionId}/customProperties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomProperties>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomProperties) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomProperties)));
        }

        /// <summary>
        /// Get custom property values for an element version (since 1.9) Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>Task of CustomProperties</returns>
        public async System.Threading.Tasks.Task<CustomProperties> GetCustomPropertiesAsync (string rkVersionId)
        {
             ApiResponse<CustomProperties> localVarResponse = await GetCustomPropertiesAsyncWithHttpInfo(rkVersionId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get custom property values for an element version (since 1.9) Return the map of custom property names and their assigned value, either assigned directly to an element version, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version to fetch</param>
        /// <returns>Task of ApiResponse (CustomProperties)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomProperties>> GetCustomPropertiesAsyncWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetCustomProperties");

            var localVarPath = "/versions/{rkVersionId}/customProperties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomProperties>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomProperties) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomProperties)));
        }

        /// <summary>
        /// Get a custom property type (since 1.9) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType GetCustomPropertyTypeById (string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = GetCustomPropertyTypeByIdWithHttpInfo(rkCustomPropertyTypeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a custom property type (since 1.9) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > GetCustomPropertyTypeByIdWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling VersionsApi->GetCustomPropertyTypeById");

            var localVarPath = "/versions/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypeById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Get a custom property type (since 1.9) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypeByIdAsync (string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await GetCustomPropertyTypeByIdAsyncWithHttpInfo(rkCustomPropertyTypeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a custom property type (since 1.9) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypeByIdAsyncWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling VersionsApi->GetCustomPropertyTypeById");

            var localVarPath = "/versions/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypeById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Search custom property types (since 1.9) Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType GetCustomPropertyTypes (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {
             ApiResponse<CustomPropertyType> localVarResponse = GetCustomPropertyTypesWithHttpInfo(allowMultilineValues, availableValues, defaultValue, description, id, inheritDefault, maxCharacters, maxValue, minValue, name, subDescription, textEditorWidth, type);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search custom property types (since 1.9) Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > GetCustomPropertyTypesWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {

            var localVarPath = "/versions/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (allowMultilineValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "allowMultilineValues", allowMultilineValues)); // query parameter
            if (availableValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "availableValues", availableValues)); // query parameter
            if (defaultValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "defaultValue", defaultValue)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (inheritDefault != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inheritDefault", inheritDefault)); // query parameter
            if (maxCharacters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxCharacters", maxCharacters)); // query parameter
            if (maxValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxValue", maxValue)); // query parameter
            if (minValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "minValue", minValue)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (textEditorWidth != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "textEditorWidth", textEditorWidth)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Search custom property types (since 1.9) Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypesAsync (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await GetCustomPropertyTypesAsyncWithHttpInfo(allowMultilineValues, availableValues, defaultValue, description, id, inheritDefault, maxCharacters, maxValue, minValue, name, subDescription, textEditorWidth, type);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search custom property types (since 1.9) Returns all custom property type definitions that can be applied to an element version, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypesAsyncWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {

            var localVarPath = "/versions/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (allowMultilineValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "allowMultilineValues", allowMultilineValues)); // query parameter
            if (availableValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "availableValues", availableValues)); // query parameter
            if (defaultValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "defaultValue", defaultValue)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (inheritDefault != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inheritDefault", inheritDefault)); // query parameter
            if (maxCharacters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxCharacters", maxCharacters)); // query parameter
            if (maxValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxValue", maxValue)); // query parameter
            if (minValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "minValue", minValue)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (textEditorWidth != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "textEditorWidth", textEditorWidth)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Get element version attributes by ID (since 1.5) Returns the attributes map for an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>ValueTypeAttribute</returns>
        public ValueTypeAttribute GetElementVersionAttributes (string rkVersionId)
        {
             ApiResponse<ValueTypeAttribute> localVarResponse = GetElementVersionAttributesWithHttpInfo(rkVersionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get element version attributes by ID (since 1.5) Returns the attributes map for an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>ApiResponse of ValueTypeAttribute</returns>
        public ApiResponse< ValueTypeAttribute > GetElementVersionAttributesWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetElementVersionAttributes");

            var localVarPath = "/versions/{rkVersionId}/attributes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ValueTypeAttribute>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ValueTypeAttribute) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ValueTypeAttribute)));
        }

        /// <summary>
        /// Get element version attributes by ID (since 1.5) Returns the attributes map for an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>Task of ValueTypeAttribute</returns>
        public async System.Threading.Tasks.Task<ValueTypeAttribute> GetElementVersionAttributesAsync (string rkVersionId)
        {
             ApiResponse<ValueTypeAttribute> localVarResponse = await GetElementVersionAttributesAsyncWithHttpInfo(rkVersionId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get element version attributes by ID (since 1.5) Returns the attributes map for an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version attributes to fetch</param>
        /// <returns>Task of ApiResponse (ValueTypeAttribute)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ValueTypeAttribute>> GetElementVersionAttributesAsyncWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetElementVersionAttributes");

            var localVarPath = "/versions/{rkVersionId}/attributes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionAttributes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ValueTypeAttribute>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ValueTypeAttribute) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ValueTypeAttribute)));
        }

        /// <summary>
        /// Get element version content by ID (since 1.5) Returns the archived content data for the given element version. Binary content is not supported.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>string</returns>
        public string GetElementVersionContent (string rkVersionId, string sizeLimit = null)
        {
             ApiResponse<string> localVarResponse = GetElementVersionContentWithHttpInfo(rkVersionId, sizeLimit);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get element version content by ID (since 1.5) Returns the archived content data for the given element version. Binary content is not supported.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > GetElementVersionContentWithHttpInfo (string rkVersionId, string sizeLimit = null)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetElementVersionContent");

            var localVarPath = "/versions/{rkVersionId}/content";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (sizeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sizeLimit", sizeLimit)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionContent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Get element version content by ID (since 1.5) Returns the archived content data for the given element version. Binary content is not supported.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetElementVersionContentAsync (string rkVersionId, string sizeLimit = null)
        {
             ApiResponse<string> localVarResponse = await GetElementVersionContentAsyncWithHttpInfo(rkVersionId, sizeLimit);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get element version content by ID (since 1.5) Returns the archived content data for the given element version. Binary content is not supported.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <param name="sizeLimit">Fail if content size exceeds this limit of size in bytes. (optional)</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> GetElementVersionContentAsyncWithHttpInfo (string rkVersionId, string sizeLimit = null)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetElementVersionContent");

            var localVarPath = "/versions/{rkVersionId}/content";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (sizeLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "sizeLimit", sizeLimit)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionContent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Get element version details by ID (since 1.5) Returns an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>ElementVersion</returns>
        public ElementVersion GetElementVersionDetailsById (string rkVersionId)
        {
             ApiResponse<ElementVersion> localVarResponse = GetElementVersionDetailsByIdWithHttpInfo(rkVersionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get element version details by ID (since 1.5) Returns an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        public ApiResponse< ElementVersion > GetElementVersionDetailsByIdWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetElementVersionDetailsById");

            var localVarPath = "/versions/{rkVersionId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionDetailsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Get element version details by ID (since 1.5) Returns an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>Task of ElementVersion</returns>
        public async System.Threading.Tasks.Task<ElementVersion> GetElementVersionDetailsByIdAsync (string rkVersionId)
        {
             ApiResponse<ElementVersion> localVarResponse = await GetElementVersionDetailsByIdAsyncWithHttpInfo(rkVersionId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get element version details by ID (since 1.5) Returns an element version with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">ID of element version details to fetch</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ElementVersion>> GetElementVersionDetailsByIdAsyncWithHttpInfo (string rkVersionId)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->GetElementVersionDetailsById");

            var localVarPath = "/versions/{rkVersionId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionDetailsById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7) Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ElementVersionWithAttributes</returns>
        public ElementVersionWithAttributes GetElementVersionsExtract (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null)
        {
             ApiResponse<ElementVersionWithAttributes> localVarResponse = GetElementVersionsExtractWithHttpInfo(pageLimit, previousId, scanId, timeDetectedRange, timeReceivedRange);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7) Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ApiResponse of ElementVersionWithAttributes</returns>
        public ApiResponse< ElementVersionWithAttributes > GetElementVersionsExtractWithHttpInfo (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null)
        {

            var localVarPath = "/versions/_extract";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (previousId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "previousId", previousId)); // query parameter
            if (scanId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "scanId", scanId)); // query parameter
            if (timeDetectedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeDetectedRange", timeDetectedRange)); // query parameter
            if (timeReceivedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeReceivedRange", timeReceivedRange)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionsExtract", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersionWithAttributes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersionWithAttributes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersionWithAttributes)));
        }

        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7) Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ElementVersionWithAttributes</returns>
        public async System.Threading.Tasks.Task<ElementVersionWithAttributes> GetElementVersionsExtractAsync (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null)
        {
             ApiResponse<ElementVersionWithAttributes> localVarResponse = await GetElementVersionsExtractAsyncWithHttpInfo(pageLimit, previousId, scanId, timeDetectedRange, timeReceivedRange);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Extract large sets of element versions incrementally (since 1.7) Search for element versions by time ranges. Time received is a valid for element versions created after TE 8.5.0. However it may be null in the database for element versions in the  prior to that. Time detected can be used for legacy element versions prior to the existence of time Received. Results will be sorted by the element version id, in ascending order. One of timeDetectedRange or timeReceivedRange must be specified.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">The maximum number of element versions to return per request. (optional)</param>
        /// <param name="previousId">When paging, this should be the last element version id returned by the previous page (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (ElementVersionWithAttributes)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ElementVersionWithAttributes>> GetElementVersionsExtractAsyncWithHttpInfo (string pageLimit = null, string previousId = null, List<string> scanId = null, string timeDetectedRange = null, string timeReceivedRange = null)
        {

            var localVarPath = "/versions/_extract";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (previousId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "previousId", previousId)); // query parameter
            if (scanId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "scanId", scanId)); // query parameter
            if (timeDetectedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeDetectedRange", timeDetectedRange)); // query parameter
            if (timeReceivedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeReceivedRange", timeReceivedRange)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetElementVersionsExtract", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersionWithAttributes>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersionWithAttributes) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersionWithAttributes)));
        }

        /// <summary>
        /// Search all element versions (since 1.5) Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ElementVersion</returns>
        public ElementVersion GetHistoricalElementVersions (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {
             ApiResponse<ElementVersion> localVarResponse = GetHistoricalElementVersionsWithHttpInfo(approvalId, at, baselineVersion, changeType, elementId, elementName, exists, hash, id, isPromoted, md5, nodeId, nodeLabel, outsideMaintenanceWindow, pageLimit, pageStart, promotionComment, ruleId, ruleName, scanId, severity, severityRange, sha1, sha256, sha512, timeDetected, timeDetectedRange, timeReceived, timeReceivedRange);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search all element versions (since 1.5) Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        public ApiResponse< ElementVersion > GetHistoricalElementVersionsWithHttpInfo (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {

            var localVarPath = "/versions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (approvalId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "approvalId", approvalId)); // query parameter
            if (at != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "at", at)); // query parameter
            if (baselineVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "baselineVersion", baselineVersion)); // query parameter
            if (changeType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "changeType", changeType)); // query parameter
            if (elementId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementId", elementId)); // query parameter
            if (elementName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementName", elementName)); // query parameter
            if (exists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "exists", exists)); // query parameter
            if (hash != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "hash", hash)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (isPromoted != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isPromoted", isPromoted)); // query parameter
            if (md5 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "md5", md5)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeId", nodeId)); // query parameter
            if (nodeLabel != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeLabel", nodeLabel)); // query parameter
            if (outsideMaintenanceWindow != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "outsideMaintenanceWindow", outsideMaintenanceWindow)); // query parameter
            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (promotionComment != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "promotionComment", promotionComment)); // query parameter
            if (ruleId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleId", ruleId)); // query parameter
            if (ruleName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleName", ruleName)); // query parameter
            if (scanId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "scanId", scanId)); // query parameter
            if (severity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "severity", severity)); // query parameter
            if (severityRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severityRange", severityRange)); // query parameter
            if (sha1 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha1", sha1)); // query parameter
            if (sha256 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha256", sha256)); // query parameter
            if (sha512 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha512", sha512)); // query parameter
            if (timeDetected != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeDetected", timeDetected)); // query parameter
            if (timeDetectedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeDetectedRange", timeDetectedRange)); // query parameter
            if (timeReceived != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeReceived", timeReceived)); // query parameter
            if (timeReceivedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeReceivedRange", timeReceivedRange)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetHistoricalElementVersions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Search all element versions (since 1.5) Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ElementVersion</returns>
        public async System.Threading.Tasks.Task<ElementVersion> GetHistoricalElementVersionsAsync (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {
             ApiResponse<ElementVersion> localVarResponse = await GetHistoricalElementVersionsAsyncWithHttpInfo(approvalId, at, baselineVersion, changeType, elementId, elementName, exists, hash, id, isPromoted, md5, nodeId, nodeLabel, outsideMaintenanceWindow, pageLimit, pageStart, promotionComment, ruleId, ruleName, scanId, severity, severityRange, sha1, sha256, sha512, timeDetected, timeDetectedRange, timeReceived, timeReceivedRange);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search all element versions (since 1.5) Returns all Element Versions that meet the search critiera. This can be used to include historical Element Versions. Element Versions for Nodes that the user does not have access to will be omitted from the search results. The &#39;at&#39; and &#39;timeDetectedRange&#39; filters are mutually exclusive.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="at">Include the latest element versions that are at or prior to the specified time. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ElementVersion>> GetHistoricalElementVersionsAsyncWithHttpInfo (List<string> approvalId = null, string at = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {

            var localVarPath = "/versions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (approvalId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "approvalId", approvalId)); // query parameter
            if (at != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "at", at)); // query parameter
            if (baselineVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "baselineVersion", baselineVersion)); // query parameter
            if (changeType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "changeType", changeType)); // query parameter
            if (elementId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementId", elementId)); // query parameter
            if (elementName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementName", elementName)); // query parameter
            if (exists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "exists", exists)); // query parameter
            if (hash != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "hash", hash)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (isPromoted != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isPromoted", isPromoted)); // query parameter
            if (md5 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "md5", md5)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeId", nodeId)); // query parameter
            if (nodeLabel != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeLabel", nodeLabel)); // query parameter
            if (outsideMaintenanceWindow != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "outsideMaintenanceWindow", outsideMaintenanceWindow)); // query parameter
            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (promotionComment != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "promotionComment", promotionComment)); // query parameter
            if (ruleId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleId", ruleId)); // query parameter
            if (ruleName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleName", ruleName)); // query parameter
            if (scanId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "scanId", scanId)); // query parameter
            if (severity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "severity", severity)); // query parameter
            if (severityRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severityRange", severityRange)); // query parameter
            if (sha1 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha1", sha1)); // query parameter
            if (sha256 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha256", sha256)); // query parameter
            if (sha512 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha512", sha512)); // query parameter
            if (timeDetected != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeDetected", timeDetected)); // query parameter
            if (timeDetectedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeDetectedRange", timeDetectedRange)); // query parameter
            if (timeReceived != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeReceived", timeReceived)); // query parameter
            if (timeReceivedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeReceivedRange", timeReceivedRange)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetHistoricalElementVersions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Search for latest element versions only (since 1.5) Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ElementVersion</returns>
        public ElementVersion GetLatestElementVersions (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {
             ApiResponse<ElementVersion> localVarResponse = GetLatestElementVersionsWithHttpInfo(approvalId, baselineVersion, changeType, elementId, elementName, exists, hash, id, isPromoted, md5, nodeId, nodeLabel, outsideMaintenanceWindow, pageLimit, pageStart, promotionComment, ruleId, ruleName, scanId, severity, severityRange, sha1, sha256, sha512, timeDetected, timeDetectedRange, timeReceived, timeReceivedRange);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search for latest element versions only (since 1.5) Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        public ApiResponse< ElementVersion > GetLatestElementVersionsWithHttpInfo (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {

            var localVarPath = "/versions/latest";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (approvalId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "approvalId", approvalId)); // query parameter
            if (baselineVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "baselineVersion", baselineVersion)); // query parameter
            if (changeType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "changeType", changeType)); // query parameter
            if (elementId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementId", elementId)); // query parameter
            if (elementName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementName", elementName)); // query parameter
            if (exists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "exists", exists)); // query parameter
            if (hash != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "hash", hash)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (isPromoted != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isPromoted", isPromoted)); // query parameter
            if (md5 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "md5", md5)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeId", nodeId)); // query parameter
            if (nodeLabel != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeLabel", nodeLabel)); // query parameter
            if (outsideMaintenanceWindow != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "outsideMaintenanceWindow", outsideMaintenanceWindow)); // query parameter
            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (promotionComment != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "promotionComment", promotionComment)); // query parameter
            if (ruleId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleId", ruleId)); // query parameter
            if (ruleName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleName", ruleName)); // query parameter
            if (scanId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "scanId", scanId)); // query parameter
            if (severity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "severity", severity)); // query parameter
            if (severityRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severityRange", severityRange)); // query parameter
            if (sha1 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha1", sha1)); // query parameter
            if (sha256 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha256", sha256)); // query parameter
            if (sha512 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha512", sha512)); // query parameter
            if (timeDetected != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeDetected", timeDetected)); // query parameter
            if (timeDetectedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeDetectedRange", timeDetectedRange)); // query parameter
            if (timeReceived != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeReceived", timeReceived)); // query parameter
            if (timeReceivedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeReceivedRange", timeReceivedRange)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLatestElementVersions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Search for latest element versions only (since 1.5) Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ElementVersion</returns>
        public async System.Threading.Tasks.Task<ElementVersion> GetLatestElementVersionsAsync (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {
             ApiResponse<ElementVersion> localVarResponse = await GetLatestElementVersionsAsyncWithHttpInfo(approvalId, baselineVersion, changeType, elementId, elementName, exists, hash, id, isPromoted, md5, nodeId, nodeLabel, outsideMaintenanceWindow, pageLimit, pageStart, promotionComment, ruleId, ruleName, scanId, severity, severityRange, sha1, sha256, sha512, timeDetected, timeDetectedRange, timeReceived, timeReceivedRange);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search for latest element versions only (since 1.5) Returns only the most recent element version for each element that matches the search criteria. Element versions for nodes that the user does not have access to will be omitted from the search results.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="approvalId">Approval IDs of elements versions to fetch. (optional)</param>
        /// <param name="baselineVersion">Last baseline versions of elements versions to fetch. (optional)</param>
        /// <param name="changeType">Change types of elements versions to fetch. (optional)</param>
        /// <param name="elementId">Elements IDs of elements versions to fetch. (optional)</param>
        /// <param name="elementName">Element names of elements versions to fetch. (optional)</param>
        /// <param name="exists">Exists condition of elements versions to fetch. (optional)</param>
        /// <param name="hash">Possible Hashes value (md5, sha1, sha256, sha512) of elements versions to fetch. (optional)</param>
        /// <param name="id">IDs of element versions to fetch. (optional)</param>
        /// <param name="isPromoted">True if the element version has been promoted. (optional)</param>
        /// <param name="md5">MD5 hashes of elements versions to fetch. (optional)</param>
        /// <param name="nodeId">Nodes IDs of elements versions to fetch. (optional)</param>
        /// <param name="nodeLabel">Nodes names of elements versions to fetch. (optional)</param>
        /// <param name="outsideMaintenanceWindow">Outside maintenance window condition of elements versions to fetch. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="promotionComment">Promotion comments of elements versions to fetch. (optional)</param>
        /// <param name="ruleId">Rules IDs of elements versions to fetch. (optional)</param>
        /// <param name="ruleName">Rules names of elements versions to fetch. (optional)</param>
        /// <param name="scanId">Scan IDs of elements versions to fetch. (optional)</param>
        /// <param name="severity">Severities of elements versions to fetch. (optional)</param>
        /// <param name="severityRange">Filter for element versions with severity in the comma separated range of values, inclusively (optional)</param>
        /// <param name="sha1">SHA1 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha256">SHA256 hashes of elements versions to fetch. (optional)</param>
        /// <param name="sha512">SHA512 hashes of elements versions to fetch. (optional)</param>
        /// <param name="timeDetected">Times detected of elements versions to fetch. (optional)</param>
        /// <param name="timeDetectedRange">Time detected range of element versions to fetch. (optional)</param>
        /// <param name="timeReceived">Times received of elements versions to fetch. (optional)</param>
        /// <param name="timeReceivedRange">Time received range of element versions to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ElementVersion>> GetLatestElementVersionsAsyncWithHttpInfo (List<string> approvalId = null, List<string> baselineVersion = null, List<string> changeType = null, List<string> elementId = null, List<string> elementName = null, bool? exists = null, List<string> hash = null, List<string> id = null, bool? isPromoted = null, List<string> md5 = null, List<string> nodeId = null, List<string> nodeLabel = null, bool? outsideMaintenanceWindow = null, string pageLimit = null, string pageStart = null, List<string> promotionComment = null, List<string> ruleId = null, List<string> ruleName = null, List<string> scanId = null, List<string> severity = null, string severityRange = null, List<string> sha1 = null, List<string> sha256 = null, List<string> sha512 = null, List<string> timeDetected = null, string timeDetectedRange = null, List<string> timeReceived = null, string timeReceivedRange = null)
        {

            var localVarPath = "/versions/latest";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (approvalId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "approvalId", approvalId)); // query parameter
            if (baselineVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "baselineVersion", baselineVersion)); // query parameter
            if (changeType != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "changeType", changeType)); // query parameter
            if (elementId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementId", elementId)); // query parameter
            if (elementName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementName", elementName)); // query parameter
            if (exists != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "exists", exists)); // query parameter
            if (hash != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "hash", hash)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (isPromoted != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isPromoted", isPromoted)); // query parameter
            if (md5 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "md5", md5)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeId", nodeId)); // query parameter
            if (nodeLabel != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeLabel", nodeLabel)); // query parameter
            if (outsideMaintenanceWindow != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "outsideMaintenanceWindow", outsideMaintenanceWindow)); // query parameter
            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (promotionComment != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "promotionComment", promotionComment)); // query parameter
            if (ruleId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleId", ruleId)); // query parameter
            if (ruleName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleName", ruleName)); // query parameter
            if (scanId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "scanId", scanId)); // query parameter
            if (severity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "severity", severity)); // query parameter
            if (severityRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "severityRange", severityRange)); // query parameter
            if (sha1 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha1", sha1)); // query parameter
            if (sha256 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha256", sha256)); // query parameter
            if (sha512 != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sha512", sha512)); // query parameter
            if (timeDetected != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeDetected", timeDetected)); // query parameter
            if (timeDetectedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeDetectedRange", timeDetectedRange)); // query parameter
            if (timeReceived != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeReceived", timeReceived)); // query parameter
            if (timeReceivedRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeReceivedRange", timeReceivedRange)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetLatestElementVersions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Get promote request status (since 1.11) Returns the promote versions request along with the completion status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>PromoteRequestCommand</returns>
        public PromoteRequestCommand GetPromoteRequestById (string requestId)
        {
             ApiResponse<PromoteRequestCommand> localVarResponse = GetPromoteRequestByIdWithHttpInfo(requestId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get promote request status (since 1.11) Returns the promote versions request along with the completion status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>ApiResponse of PromoteRequestCommand</returns>
        public ApiResponse< PromoteRequestCommand > GetPromoteRequestByIdWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling VersionsApi->GetPromoteRequestById");

            var localVarPath = "/versions/promoteRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPromoteRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PromoteRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PromoteRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PromoteRequestCommand)));
        }

        /// <summary>
        /// Get promote request status (since 1.11) Returns the promote versions request along with the completion status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of PromoteRequestCommand</returns>
        public async System.Threading.Tasks.Task<PromoteRequestCommand> GetPromoteRequestByIdAsync (string requestId)
        {
             ApiResponse<PromoteRequestCommand> localVarResponse = await GetPromoteRequestByIdAsyncWithHttpInfo(requestId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get promote request status (since 1.11) Returns the promote versions request along with the completion status.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of ApiResponse (PromoteRequestCommand)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PromoteRequestCommand>> GetPromoteRequestByIdAsyncWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling VersionsApi->GetPromoteRequestById");

            var localVarPath = "/versions/promoteRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPromoteRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PromoteRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PromoteRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PromoteRequestCommand)));
        }

        /// <summary>
        /// Request promotion of a set of element versions (since 1.11) Creates an asynchronous command to queue promotion of element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>PromoteRequestCommand</returns>
        public PromoteRequestCommand PromoteRequest (PromoteRequestCommand body)
        {
             ApiResponse<PromoteRequestCommand> localVarResponse = PromoteRequestWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Request promotion of a set of element versions (since 1.11) Creates an asynchronous command to queue promotion of element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>ApiResponse of PromoteRequestCommand</returns>
        public ApiResponse< PromoteRequestCommand > PromoteRequestWithHttpInfo (PromoteRequestCommand body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->PromoteRequest");

            var localVarPath = "/versions/promoteRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PromoteRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PromoteRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PromoteRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PromoteRequestCommand)));
        }

        /// <summary>
        /// Request promotion of a set of element versions (since 1.11) Creates an asynchronous command to queue promotion of element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of PromoteRequestCommand</returns>
        public async System.Threading.Tasks.Task<PromoteRequestCommand> PromoteRequestAsync (PromoteRequestCommand body)
        {
             ApiResponse<PromoteRequestCommand> localVarResponse = await PromoteRequestAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Request promotion of a set of element versions (since 1.11) Creates an asynchronous command to queue promotion of element versions.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Version creation request to be executed</param>
        /// <returns>Task of ApiResponse (PromoteRequestCommand)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PromoteRequestCommand>> PromoteRequestAsyncWithHttpInfo (PromoteRequestCommand body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->PromoteRequest");

            var localVarPath = "/versions/promoteRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PromoteRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PromoteRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PromoteRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(PromoteRequestCommand)));
        }

        /// <summary>
        /// Set a custom property value for an element version (since 1.9) Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns></returns>
        public void SetElementVersionCustomProperty (string rkVersionId, string propertyName, PropertyValue body)
        {
             SetElementVersionCustomPropertyWithHttpInfo(rkVersionId, propertyName, body);
        }

        /// <summary>
        /// Set a custom property value for an element version (since 1.9) Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> SetElementVersionCustomPropertyWithHttpInfo (string rkVersionId, string propertyName, PropertyValue body)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->SetElementVersionCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling VersionsApi->SetElementVersionCustomProperty");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->SetElementVersionCustomProperty");

            var localVarPath = "/versions/{rkVersionId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetElementVersionCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Set a custom property value for an element version (since 1.9) Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetElementVersionCustomPropertyAsync (string rkVersionId, string propertyName, PropertyValue body)
        {
             await SetElementVersionCustomPropertyAsyncWithHttpInfo(rkVersionId, propertyName, body);

        }

        /// <summary>
        /// Set a custom property value for an element version (since 1.9) Assign a custom property value to an element version. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the element version, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version.</param>
        /// <param name="propertyName">Name of the custom property type to assign to the element version.</param>
        /// <param name="body">Value to assign to the custom property of the element version.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> SetElementVersionCustomPropertyAsyncWithHttpInfo (string rkVersionId, string propertyName, PropertyValue body)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->SetElementVersionCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling VersionsApi->SetElementVersionCustomProperty");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->SetElementVersionCustomProperty");

            var localVarPath = "/versions/{rkVersionId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetElementVersionCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Update an existing element version custom property type (since 1.9) Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType UpdateCustomPropertyType (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = UpdateCustomPropertyTypeWithHttpInfo(body, rkCustomPropertyTypeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an existing element version custom property type (since 1.9) Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > UpdateCustomPropertyTypeWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->UpdateCustomPropertyType");
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling VersionsApi->UpdateCustomPropertyType");

            var localVarPath = "/versions/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Update an existing element version custom property type (since 1.9) Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> UpdateCustomPropertyTypeAsync (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await UpdateCustomPropertyTypeAsyncWithHttpInfo(body, rkCustomPropertyTypeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an existing element version custom property type (since 1.9) Modifies an element custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> UpdateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->UpdateCustomPropertyType");
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling VersionsApi->UpdateCustomPropertyType");

            var localVarPath = "/versions/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Put an update to an element version (since 1.7) Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>ElementVersion</returns>
        public ElementVersion UpdateElementVersion (string rkVersionId, ElementVersionSeverity body)
        {
             ApiResponse<ElementVersion> localVarResponse = UpdateElementVersionWithHttpInfo(rkVersionId, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Put an update to an element version (since 1.7) Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>ApiResponse of ElementVersion</returns>
        public ApiResponse< ElementVersion > UpdateElementVersionWithHttpInfo (string rkVersionId, ElementVersionSeverity body)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->UpdateElementVersion");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->UpdateElementVersion");

            var localVarPath = "/versions/{rkVersionId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateElementVersion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

        /// <summary>
        /// Put an update to an element version (since 1.7) Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>Task of ElementVersion</returns>
        public async System.Threading.Tasks.Task<ElementVersion> UpdateElementVersionAsync (string rkVersionId, ElementVersionSeverity body)
        {
             ApiResponse<ElementVersion> localVarResponse = await UpdateElementVersionAsyncWithHttpInfo(rkVersionId, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Put an update to an element version (since 1.7) Modifies the specified element version with a new severity value. Only the severity field is modifiable.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkVersionId">Id of the element version to modify</param>
        /// <param name="body">Element version description to update the existing element version.</param>
        /// <returns>Task of ApiResponse (ElementVersion)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ElementVersion>> UpdateElementVersionAsyncWithHttpInfo (string rkVersionId, ElementVersionSeverity body)
        {
            // verify the required parameter 'rkVersionId' is set
            if (rkVersionId == null)
                throw new ApiException(400, "Missing required parameter 'rkVersionId' when calling VersionsApi->UpdateElementVersion");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling VersionsApi->UpdateElementVersion");

            var localVarPath = "/versions/{rkVersionId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkVersionId != null) localVarPathParams.Add("rkVersionId", this.Configuration.ApiClient.ParameterToString(rkVersionId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateElementVersion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ElementVersion>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ElementVersion) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ElementVersion)));
        }

    }
}
