/* 
 * Tripwire Enterprise TE REST API User Guide & Reference
 *
 * The TE REST API allows automation of many aspects of Tripwire Enterprise
 *
 * OpenAPI spec version: 1.13.0.bmaster.r20180119190259-8b60eaa.b1753
 * Contact: support@tripwire.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface INodesApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Create a node custom property definition (since 1.5)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType CreateCustomPropertyType (CustomPropertyType body);

        /// <summary>
        /// Create a node custom property definition (since 1.5)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> CreateCustomPropertyTypeWithHttpInfo (CustomPropertyType body);
        /// <summary>
        /// Create a node (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>Node</returns>
        Node CreateNode (Node body);

        /// <summary>
        /// Create a node (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>ApiResponse of Node</returns>
        ApiResponse<Node> CreateNodeWithHttpInfo (Node body);
        /// <summary>
        /// Post a new node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Replaces the access control list for a node with the new submitted set of entries.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>string</returns>
        string CreateNodeAcl (string rkNodeId, Object body);

        /// <summary>
        /// Post a new node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Replaces the access control list for a node with the new submitted set of entries.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> CreateNodeAclWithHttpInfo (string rkNodeId, Object body);
        /// <summary>
        /// Delete a custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Delete an existing node custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns></returns>
        void DeleteCustomPropertyType (string rkCustomPropertyTypeId);

        /// <summary>
        /// Delete a custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Delete an existing node custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteCustomPropertyTypeWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns></returns>
        void DeleteNode (string rkNodeId);

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteNodeWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Delete a custom property value from a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns></returns>
        void DeleteNodeCustomProperty (string rkNodeId, string propertyName);

        /// <summary>
        /// Delete a custom property value from a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteNodeCustomPropertyWithHttpInfo (string rkNodeId, string propertyName);
        /// <summary>
        /// Get custom property values for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>CustomProperties</returns>
        CustomProperties GetCustomProperties (string rkNodeId);

        /// <summary>
        /// Get custom property values for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>ApiResponse of CustomProperties</returns>
        ApiResponse<CustomProperties> GetCustomPropertiesWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Get a custom property type (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType GetCustomPropertyTypeById (string rkCustomPropertyTypeId);

        /// <summary>
        /// Get a custom property type (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> GetCustomPropertyTypeByIdWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Search custom property types (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType GetCustomPropertyTypes (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);

        /// <summary>
        /// Search custom property types (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> GetCustomPropertyTypesWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);
        /// <summary>
        /// Get node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Returns the access control list for the specified node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>string</returns>
        string GetNodeAcl (string rkNodeId);

        /// <summary>
        /// Get node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Returns the access control list for the specified node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> GetNodeAclWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Get node details by ID (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Node</returns>
        Node GetNodeById (string rkNodeId);

        /// <summary>
        /// Get node details by ID (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>ApiResponse of Node</returns>
        ApiResponse<Node> GetNodeByIdWithHttpInfo (string rkNodeId);
        /// <summary>
        /// List parent groups for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns a list of the parent groups for a node with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>NodeGroupPath</returns>
        NodeGroupPath GetNodeParentGroups (string rkNodeId);

        /// <summary>
        /// List parent groups for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns a list of the parent groups for a node with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>ApiResponse of NodeGroupPath</returns>
        ApiResponse<NodeGroupPath> GetNodeParentGroupsWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Search nodes (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>Node</returns>
        Node GetNodes (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null);

        /// <summary>
        /// Search nodes (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>ApiResponse of Node</returns>
        ApiResponse<Node> GetNodesWithHttpInfo (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null);
        /// <summary>
        /// Get the status of a rule run request (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>RuleRunRequestCommand</returns>
        RuleRunRequestCommand GetRuleRunRequestById (string requestId);

        /// <summary>
        /// Get the status of a rule run request (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>ApiResponse of RuleRunRequestCommand</returns>
        ApiResponse<RuleRunRequestCommand> GetRuleRunRequestByIdWithHttpInfo (string requestId);
        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>NodeRestartResult</returns>
        NodeRestartResult RestartNodes (NodeRestart body = null);

        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>ApiResponse of NodeRestartResult</returns>
        ApiResponse<NodeRestartResult> RestartNodesWithHttpInfo (NodeRestart body = null);
        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns></returns>
        void RetireNode (string rkNodeId);

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RetireNodeWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Run rules on nodes (since 1.11)
        /// </summary>
        /// <remarks>
        /// Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>RuleRunRequestCommand</returns>
        RuleRunRequestCommand RuleRunRequest (RuleRunRequestCommand body);

        /// <summary>
        /// Run rules on nodes (since 1.11)
        /// </summary>
        /// <remarks>
        /// Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>ApiResponse of RuleRunRequestCommand</returns>
        ApiResponse<RuleRunRequestCommand> RuleRunRequestWithHttpInfo (RuleRunRequestCommand body);
        /// <summary>
        /// Set a custom property value for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns></returns>
        void SetNodeCustomProperty (string rkNodeId, string propertyName, PropertyValue body);

        /// <summary>
        /// Set a custom property value for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> SetNodeCustomPropertyWithHttpInfo (string rkNodeId, string propertyName, PropertyValue body);
        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns></returns>
        void UnregisterCommonAgent (string rkNodeId);

        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UnregisterCommonAgentWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Update an existing node custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>CustomPropertyType</returns>
        CustomPropertyType UpdateCustomPropertyType (CustomPropertyType body, string rkCustomPropertyTypeId);

        /// <summary>
        /// Update an existing node custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        ApiResponse<CustomPropertyType> UpdateCustomPropertyTypeWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId);
        /// <summary>
        /// Update a node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>Node</returns>
        Node UpdateNode (string rkNodeId, Node body);

        /// <summary>
        /// Update a node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>ApiResponse of Node</returns>
        ApiResponse<Node> UpdateNodeWithHttpInfo (string rkNodeId, Node body);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Create a node custom property definition (since 1.5)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> CreateCustomPropertyTypeAsync (CustomPropertyType body);

        /// <summary>
        /// Create a node custom property definition (since 1.5)
        /// </summary>
        /// <remarks>
        /// Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> CreateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body);
        /// <summary>
        /// Create a node (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>Task of Node</returns>
        System.Threading.Tasks.Task<Node> CreateNodeAsync (Node body);

        /// <summary>
        /// Create a node (since 1.11)
        /// </summary>
        /// <remarks>
        /// Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<Node>> CreateNodeAsyncWithHttpInfo (Node body);
        /// <summary>
        /// Post a new node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Replaces the access control list for a node with the new submitted set of entries.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> CreateNodeAclAsync (string rkNodeId, Object body);

        /// <summary>
        /// Post a new node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Replaces the access control list for a node with the new submitted set of entries.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> CreateNodeAclAsyncWithHttpInfo (string rkNodeId, Object body);
        /// <summary>
        /// Delete a custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Delete an existing node custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteCustomPropertyTypeAsync (string rkCustomPropertyTypeId);

        /// <summary>
        /// Delete a custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Delete an existing node custom property type
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteCustomPropertyTypeAsyncWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteNodeAsync (string rkNodeId);

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodeAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Delete a custom property value from a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteNodeCustomPropertyAsync (string rkNodeId, string propertyName);

        /// <summary>
        /// Delete a custom property value from a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodeCustomPropertyAsyncWithHttpInfo (string rkNodeId, string propertyName);
        /// <summary>
        /// Get custom property values for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of CustomProperties</returns>
        System.Threading.Tasks.Task<CustomProperties> GetCustomPropertiesAsync (string rkNodeId);

        /// <summary>
        /// Get custom property values for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of ApiResponse (CustomProperties)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomProperties>> GetCustomPropertiesAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Get a custom property type (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypeByIdAsync (string rkCustomPropertyTypeId);

        /// <summary>
        /// Get a custom property type (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns the details of a custom property type.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypeByIdAsyncWithHttpInfo (string rkCustomPropertyTypeId);
        /// <summary>
        /// Search custom property types (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypesAsync (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);

        /// <summary>
        /// Search custom property types (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypesAsyncWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null);
        /// <summary>
        /// Get node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Returns the access control list for the specified node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> GetNodeAclAsync (string rkNodeId);

        /// <summary>
        /// Get node access control list (since 1.4)
        /// </summary>
        /// <remarks>
        /// Returns the access control list for the specified node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> GetNodeAclAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Get node details by ID (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of Node</returns>
        System.Threading.Tasks.Task<Node> GetNodeByIdAsync (string rkNodeId);

        /// <summary>
        /// Get node details by ID (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single node.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<Node>> GetNodeByIdAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// List parent groups for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns a list of the parent groups for a node with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of NodeGroupPath</returns>
        System.Threading.Tasks.Task<NodeGroupPath> GetNodeParentGroupsAsync (string rkNodeId);

        /// <summary>
        /// List parent groups for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Returns a list of the parent groups for a node with a specific ID.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of ApiResponse (NodeGroupPath)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodeGroupPath>> GetNodeParentGroupsAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Search nodes (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>Task of Node</returns>
        System.Threading.Tasks.Task<Node> GetNodesAsync (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null);

        /// <summary>
        /// Search nodes (since 1.3)
        /// </summary>
        /// <remarks>
        /// Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<Node>> GetNodesAsyncWithHttpInfo (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null);
        /// <summary>
        /// Get the status of a rule run request (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of RuleRunRequestCommand</returns>
        System.Threading.Tasks.Task<RuleRunRequestCommand> GetRuleRunRequestByIdAsync (string requestId);

        /// <summary>
        /// Get the status of a rule run request (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of ApiResponse (RuleRunRequestCommand)</returns>
        System.Threading.Tasks.Task<ApiResponse<RuleRunRequestCommand>> GetRuleRunRequestByIdAsyncWithHttpInfo (string requestId);
        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>Task of NodeRestartResult</returns>
        System.Threading.Tasks.Task<NodeRestartResult> RestartNodesAsync (NodeRestart body = null);

        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>Task of ApiResponse (NodeRestartResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<NodeRestartResult>> RestartNodesAsyncWithHttpInfo (NodeRestart body = null);
        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RetireNodeAsync (string rkNodeId);

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3)
        /// </summary>
        /// <remarks>
        /// Permissions needed: &#39;tool.node.load&#39;
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RetireNodeAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Run rules on nodes (since 1.11)
        /// </summary>
        /// <remarks>
        /// Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>Task of RuleRunRequestCommand</returns>
        System.Threading.Tasks.Task<RuleRunRequestCommand> RuleRunRequestAsync (RuleRunRequestCommand body);

        /// <summary>
        /// Run rules on nodes (since 1.11)
        /// </summary>
        /// <remarks>
        /// Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>Task of ApiResponse (RuleRunRequestCommand)</returns>
        System.Threading.Tasks.Task<ApiResponse<RuleRunRequestCommand>> RuleRunRequestAsyncWithHttpInfo (RuleRunRequestCommand body);
        /// <summary>
        /// Set a custom property value for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task SetNodeCustomPropertyAsync (string rkNodeId, string propertyName, PropertyValue body);

        /// <summary>
        /// Set a custom property value for a node (since 1.5)
        /// </summary>
        /// <remarks>
        /// Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> SetNodeCustomPropertyAsyncWithHttpInfo (string rkNodeId, string propertyName, PropertyValue body);
        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UnregisterCommonAgentAsync (string rkNodeId);

        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UnregisterCommonAgentAsyncWithHttpInfo (string rkNodeId);
        /// <summary>
        /// Update an existing node custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of CustomPropertyType</returns>
        System.Threading.Tasks.Task<CustomPropertyType> UpdateCustomPropertyTypeAsync (CustomPropertyType body, string rkCustomPropertyTypeId);

        /// <summary>
        /// Update an existing node custom property type (since 1.6)
        /// </summary>
        /// <remarks>
        /// Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> UpdateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId);
        /// <summary>
        /// Update a node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>Task of Node</returns>
        System.Threading.Tasks.Task<Node> UpdateNodeAsync (string rkNodeId, Node body);

        /// <summary>
        /// Update a node (since 1.4)
        /// </summary>
        /// <remarks>
        /// Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        System.Threading.Tasks.Task<ApiResponse<Node>> UpdateNodeAsyncWithHttpInfo (string rkNodeId, Node body);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class NodesApi : INodesApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="NodesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public NodesApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="NodesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public NodesApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Create a node custom property definition (since 1.5) Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType CreateCustomPropertyType (CustomPropertyType body)
        {
             ApiResponse<CustomPropertyType> localVarResponse = CreateCustomPropertyTypeWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a node custom property definition (since 1.5) Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > CreateCustomPropertyTypeWithHttpInfo (CustomPropertyType body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->CreateCustomPropertyType");

            var localVarPath = "/nodes/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Create a node custom property definition (since 1.5) Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> CreateCustomPropertyTypeAsync (CustomPropertyType body)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await CreateCustomPropertyTypeAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a node custom property definition (since 1.5) Allows creating models for custom meta-data that can be later applied to nodes to be retrieved later, or used in filtering.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be created</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> CreateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->CreateCustomPropertyType");

            var localVarPath = "/nodes/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Create a node (since 1.11) Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>Node</returns>
        public Node CreateNode (Node body)
        {
             ApiResponse<Node> localVarResponse = CreateNodeWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a node (since 1.11) Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>ApiResponse of Node</returns>
        public ApiResponse< Node > CreateNodeWithHttpInfo (Node body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->CreateNode");

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// Create a node (since 1.11) Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>Task of Node</returns>
        public async System.Threading.Tasks.Task<Node> CreateNodeAsync (Node body)
        {
             ApiResponse<Node> localVarResponse = await CreateNodeAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a node (since 1.11) Creates a node with the given configuration. Many node types are supported, with unique field sets. Please see &lt;a href&#x3D;\&quot;help.html#CreateNode\&quot;&gt;help.html&lt;/a&gt; for additional detail.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Node object to be created in TE</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Node>> CreateNodeAsyncWithHttpInfo (Node body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->CreateNode");

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// Post a new node access control list (since 1.4) Replaces the access control list for a node with the new submitted set of entries.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>string</returns>
        public string CreateNodeAcl (string rkNodeId, Object body)
        {
             ApiResponse<string> localVarResponse = CreateNodeAclWithHttpInfo(rkNodeId, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Post a new node access control list (since 1.4) Replaces the access control list for a node with the new submitted set of entries.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > CreateNodeAclWithHttpInfo (string rkNodeId, Object body)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->CreateNodeAcl");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->CreateNodeAcl");

            var localVarPath = "/nodes/{rkNodeId}/acl";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNodeAcl", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Post a new node access control list (since 1.4) Replaces the access control list for a node with the new submitted set of entries.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> CreateNodeAclAsync (string rkNodeId, Object body)
        {
             ApiResponse<string> localVarResponse = await CreateNodeAclAsyncWithHttpInfo(rkNodeId, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Post a new node access control list (since 1.4) Replaces the access control list for a node with the new submitted set of entries.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch the ACL</param>
        /// <param name="body">ACL - Map of user or user group IDs to role IDs</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> CreateNodeAclAsyncWithHttpInfo (string rkNodeId, Object body)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->CreateNodeAcl");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->CreateNodeAcl");

            var localVarPath = "/nodes/{rkNodeId}/acl";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateNodeAcl", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Delete a custom property type (since 1.6) Delete an existing node custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns></returns>
        public void DeleteCustomPropertyType (string rkCustomPropertyTypeId)
        {
             DeleteCustomPropertyTypeWithHttpInfo(rkCustomPropertyTypeId);
        }

        /// <summary>
        /// Delete a custom property type (since 1.6) Delete an existing node custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteCustomPropertyTypeWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling NodesApi->DeleteCustomPropertyType");

            var localVarPath = "/nodes/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a custom property type (since 1.6) Delete an existing node custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteCustomPropertyTypeAsync (string rkCustomPropertyTypeId)
        {
             await DeleteCustomPropertyTypeAsyncWithHttpInfo(rkCustomPropertyTypeId);

        }

        /// <summary>
        /// Delete a custom property type (since 1.6) Delete an existing node custom property type
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Removes a node custom property type, and the value assignments to all nodes</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteCustomPropertyTypeAsyncWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling NodesApi->DeleteCustomPropertyType");

            var localVarPath = "/nodes/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns></returns>
        public void DeleteNode (string rkNodeId)
        {
             DeleteNodeWithHttpInfo(rkNodeId);
        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteNodeWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->DeleteNode");

            var localVarPath = "/nodes/{rkNodeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteNodeAsync (string rkNodeId)
        {
             await DeleteNodeAsyncWithHttpInfo(rkNodeId);

        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to delete</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodeAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->DeleteNode");

            var localVarPath = "/nodes/{rkNodeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a custom property value from a node (since 1.5) Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns></returns>
        public void DeleteNodeCustomProperty (string rkNodeId, string propertyName)
        {
             DeleteNodeCustomPropertyWithHttpInfo(rkNodeId, propertyName);
        }

        /// <summary>
        /// Delete a custom property value from a node (since 1.5) Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteNodeCustomPropertyWithHttpInfo (string rkNodeId, string propertyName)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->DeleteNodeCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling NodesApi->DeleteNodeCustomProperty");

            var localVarPath = "/nodes/{rkNodeId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNodeCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a custom property value from a node (since 1.5) Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteNodeCustomPropertyAsync (string rkNodeId, string propertyName)
        {
             await DeleteNodeCustomPropertyAsyncWithHttpInfo(rkNodeId, propertyName);

        }

        /// <summary>
        /// Delete a custom property value from a node (since 1.5) Removes the custom property assignment from the node. If the custom property type is configured to inherit default values, then the default for that custom property type will become active on the node. Inherited custom property values cannot be deleted and attempts to do so will result in a 404
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of node</param>
        /// <param name="propertyName">Name of node custom property to unassign from the node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteNodeCustomPropertyAsyncWithHttpInfo (string rkNodeId, string propertyName)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->DeleteNodeCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling NodesApi->DeleteNodeCustomProperty");

            var localVarPath = "/nodes/{rkNodeId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteNodeCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Get custom property values for a node (since 1.5) Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>CustomProperties</returns>
        public CustomProperties GetCustomProperties (string rkNodeId)
        {
             ApiResponse<CustomProperties> localVarResponse = GetCustomPropertiesWithHttpInfo(rkNodeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get custom property values for a node (since 1.5) Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>ApiResponse of CustomProperties</returns>
        public ApiResponse< CustomProperties > GetCustomPropertiesWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetCustomProperties");

            var localVarPath = "/nodes/{rkNodeId}/customProperties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomProperties>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomProperties) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomProperties)));
        }

        /// <summary>
        /// Get custom property values for a node (since 1.5) Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of CustomProperties</returns>
        public async System.Threading.Tasks.Task<CustomProperties> GetCustomPropertiesAsync (string rkNodeId)
        {
             ApiResponse<CustomProperties> localVarResponse = await GetCustomPropertiesAsyncWithHttpInfo(rkNodeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get custom property values for a node (since 1.5) Return the map of custom properties names and their assigned value, either assigned directly to a node, or inherited by default.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of ApiResponse (CustomProperties)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomProperties>> GetCustomPropertiesAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetCustomProperties");

            var localVarPath = "/nodes/{rkNodeId}/customProperties";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomProperties", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomProperties>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomProperties) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomProperties)));
        }

        /// <summary>
        /// Get a custom property type (since 1.5) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType GetCustomPropertyTypeById (string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = GetCustomPropertyTypeByIdWithHttpInfo(rkCustomPropertyTypeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a custom property type (since 1.5) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > GetCustomPropertyTypeByIdWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling NodesApi->GetCustomPropertyTypeById");

            var localVarPath = "/nodes/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypeById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Get a custom property type (since 1.5) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypeByIdAsync (string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await GetCustomPropertyTypeByIdAsyncWithHttpInfo(rkCustomPropertyTypeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a custom property type (since 1.5) Returns the details of a custom property type.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to fetch</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypeByIdAsyncWithHttpInfo (string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling NodesApi->GetCustomPropertyTypeById");

            var localVarPath = "/nodes/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypeById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Search custom property types (since 1.5) Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType GetCustomPropertyTypes (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {
             ApiResponse<CustomPropertyType> localVarResponse = GetCustomPropertyTypesWithHttpInfo(allowMultilineValues, availableValues, defaultValue, description, id, inheritDefault, maxCharacters, maxValue, minValue, name, subDescription, textEditorWidth, type);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search custom property types (since 1.5) Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > GetCustomPropertyTypesWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {

            var localVarPath = "/nodes/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (allowMultilineValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "allowMultilineValues", allowMultilineValues)); // query parameter
            if (availableValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "availableValues", availableValues)); // query parameter
            if (defaultValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "defaultValue", defaultValue)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (inheritDefault != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inheritDefault", inheritDefault)); // query parameter
            if (maxCharacters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxCharacters", maxCharacters)); // query parameter
            if (maxValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxValue", maxValue)); // query parameter
            if (minValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "minValue", minValue)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (textEditorWidth != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "textEditorWidth", textEditorWidth)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Search custom property types (since 1.5) Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> GetCustomPropertyTypesAsync (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await GetCustomPropertyTypesAsyncWithHttpInfo(allowMultilineValues, availableValues, defaultValue, description, id, inheritDefault, maxCharacters, maxValue, minValue, name, subDescription, textEditorWidth, type);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search custom property types (since 1.5) Returns all custom property type definitions that can be applied to nodes, or those that meet the filter criteria.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="allowMultilineValues">Allow multiline values condition of custom property types to fetch. (optional)</param>
        /// <param name="availableValues">Available values of custom property types to fetch. (optional)</param>
        /// <param name="defaultValue">Default values of custom property types to fetch. (optional)</param>
        /// <param name="description">Descriptions of custom property types to fetch. (optional)</param>
        /// <param name="id">IDs of custom property types to fetch. (optional)</param>
        /// <param name="inheritDefault">Inherit default condition of custom property types to fetch. (optional)</param>
        /// <param name="maxCharacters">Max characters conditions of custom property types to fetch. (optional)</param>
        /// <param name="maxValue">Max values of custom property types to fetch. (optional)</param>
        /// <param name="minValue">Min values of custom property types to fetch. (optional)</param>
        /// <param name="name">Names of custom property types to fetch. (optional)</param>
        /// <param name="subDescription">Substring matching for description. (optional)</param>
        /// <param name="textEditorWidth">Text editor width conditions of custom property types to fetch. (optional)</param>
        /// <param name="type">Types of custom property types to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> GetCustomPropertyTypesAsyncWithHttpInfo (bool? allowMultilineValues = null, List<string> availableValues = null, List<string> defaultValue = null, List<string> description = null, List<string> id = null, bool? inheritDefault = null, List<string> maxCharacters = null, List<string> maxValue = null, List<string> minValue = null, List<string> name = null, List<string> subDescription = null, List<string> textEditorWidth = null, List<string> type = null)
        {

            var localVarPath = "/nodes/customPropertyTypes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (allowMultilineValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "allowMultilineValues", allowMultilineValues)); // query parameter
            if (availableValues != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "availableValues", availableValues)); // query parameter
            if (defaultValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "defaultValue", defaultValue)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (inheritDefault != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "inheritDefault", inheritDefault)); // query parameter
            if (maxCharacters != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxCharacters", maxCharacters)); // query parameter
            if (maxValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxValue", maxValue)); // query parameter
            if (minValue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "minValue", minValue)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (textEditorWidth != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "textEditorWidth", textEditorWidth)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCustomPropertyTypes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Get node access control list (since 1.4) Returns the access control list for the specified node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>string</returns>
        public string GetNodeAcl (string rkNodeId)
        {
             ApiResponse<string> localVarResponse = GetNodeAclWithHttpInfo(rkNodeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get node access control list (since 1.4) Returns the access control list for the specified node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>ApiResponse of string</returns>
        public ApiResponse< string > GetNodeAclWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetNodeAcl");

            var localVarPath = "/nodes/{rkNodeId}/acl";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeAcl", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Get node access control list (since 1.4) Returns the access control list for the specified node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> GetNodeAclAsync (string rkNodeId)
        {
             ApiResponse<string> localVarResponse = await GetNodeAclAsyncWithHttpInfo(rkNodeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get node access control list (since 1.4) Returns the access control list for the specified node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of Node to fetch the ACL</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<string>> GetNodeAclAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetNodeAcl");

            var localVarPath = "/nodes/{rkNodeId}/acl";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeAcl", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<string>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (string) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(string)));
        }

        /// <summary>
        /// Get node details by ID (since 1.3) Returns the details of a single node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Node</returns>
        public Node GetNodeById (string rkNodeId)
        {
             ApiResponse<Node> localVarResponse = GetNodeByIdWithHttpInfo(rkNodeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get node details by ID (since 1.3) Returns the details of a single node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>ApiResponse of Node</returns>
        public ApiResponse< Node > GetNodeByIdWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetNodeById");

            var localVarPath = "/nodes/{rkNodeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// Get node details by ID (since 1.3) Returns the details of a single node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of Node</returns>
        public async System.Threading.Tasks.Task<Node> GetNodeByIdAsync (string rkNodeId)
        {
             ApiResponse<Node> localVarResponse = await GetNodeByIdAsyncWithHttpInfo(rkNodeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get node details by ID (since 1.3) Returns the details of a single node.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to fetch</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Node>> GetNodeByIdAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetNodeById");

            var localVarPath = "/nodes/{rkNodeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// List parent groups for a node (since 1.5) Returns a list of the parent groups for a node with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>NodeGroupPath</returns>
        public NodeGroupPath GetNodeParentGroups (string rkNodeId)
        {
             ApiResponse<NodeGroupPath> localVarResponse = GetNodeParentGroupsWithHttpInfo(rkNodeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List parent groups for a node (since 1.5) Returns a list of the parent groups for a node with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>ApiResponse of NodeGroupPath</returns>
        public ApiResponse< NodeGroupPath > GetNodeParentGroupsWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetNodeParentGroups");

            var localVarPath = "/nodes/{rkNodeId}/parentGroups";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeParentGroups", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeGroupPath>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (NodeGroupPath) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeGroupPath)));
        }

        /// <summary>
        /// List parent groups for a node (since 1.5) Returns a list of the parent groups for a node with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of NodeGroupPath</returns>
        public async System.Threading.Tasks.Task<NodeGroupPath> GetNodeParentGroupsAsync (string rkNodeId)
        {
             ApiResponse<NodeGroupPath> localVarResponse = await GetNodeParentGroupsAsyncWithHttpInfo(rkNodeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List parent groups for a node (since 1.5) Returns a list of the parent groups for a node with a specific ID.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of ApiResponse (NodeGroupPath)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodeGroupPath>> GetNodeParentGroupsAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->GetNodeParentGroups");

            var localVarPath = "/nodes/{rkNodeId}/parentGroups";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodeParentGroups", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeGroupPath>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (NodeGroupPath) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeGroupPath)));
        }

        /// <summary>
        /// Search nodes (since 1.3) Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>Node</returns>
        public Node GetNodes (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null)
        {
             ApiResponse<Node> localVarResponse = GetNodesWithHttpInfo(agentVersion, auditEnabled, commonAgentCapabilities, commonAgentOsName, commonAgentOsVersion, commonAgentUuid, commonAgentVersion, customProperty, description, elementCount, eventGeneratorEnabled, eventGeneratorInstalled, hasFailures, icName, id, importedTime, importedTimeRange, ipAddress, isDisabled, isSocksProxy, isSSLSupported, lastCheck, lastRegistration, licensedFeature, macAddress, make, maxSeverity, model, modifiedTime, name, oid, pageLimit, pageStart, proxyHost, proxyPort, realTimeEnabled, rmiHost, rmiPort, subDescription, subName, tag, trackingId, type, usingSSL, version);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search nodes (since 1.3) Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>ApiResponse of Node</returns>
        public ApiResponse< Node > GetNodesWithHttpInfo (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null)
        {

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (agentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "agentVersion", agentVersion)); // query parameter
            if (auditEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "auditEnabled", auditEnabled)); // query parameter
            if (commonAgentCapabilities != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentCapabilities", commonAgentCapabilities)); // query parameter
            if (commonAgentOsName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentOsName", commonAgentOsName)); // query parameter
            if (commonAgentOsVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentOsVersion", commonAgentOsVersion)); // query parameter
            if (commonAgentUuid != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentUuid", commonAgentUuid)); // query parameter
            if (commonAgentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentVersion", commonAgentVersion)); // query parameter
            if (customProperty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "customProperty", customProperty)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (elementCount != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementCount", elementCount)); // query parameter
            if (eventGeneratorEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "eventGeneratorEnabled", eventGeneratorEnabled)); // query parameter
            if (eventGeneratorInstalled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "eventGeneratorInstalled", eventGeneratorInstalled)); // query parameter
            if (hasFailures != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "hasFailures", hasFailures)); // query parameter
            if (icName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ic_name", icName)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (importedTime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "importedTime", importedTime)); // query parameter
            if (importedTimeRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "importedTimeRange", importedTimeRange)); // query parameter
            if (ipAddress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ipAddress", ipAddress)); // query parameter
            if (isDisabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isDisabled", isDisabled)); // query parameter
            if (isSocksProxy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isSocksProxy", isSocksProxy)); // query parameter
            if (isSSLSupported != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isSSLSupported", isSSLSupported)); // query parameter
            if (lastCheck != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastCheck", lastCheck)); // query parameter
            if (lastRegistration != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastRegistration", lastRegistration)); // query parameter
            if (licensedFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "licensedFeature", licensedFeature)); // query parameter
            if (macAddress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "macAddress", macAddress)); // query parameter
            if (make != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "make", make)); // query parameter
            if (maxSeverity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxSeverity", maxSeverity)); // query parameter
            if (model != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "model", model)); // query parameter
            if (modifiedTime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "modifiedTime", modifiedTime)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (oid != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "oid", oid)); // query parameter
            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (proxyHost != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "proxyHost", proxyHost)); // query parameter
            if (proxyPort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "proxyPort", proxyPort)); // query parameter
            if (realTimeEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "realTimeEnabled", realTimeEnabled)); // query parameter
            if (rmiHost != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "rmiHost", rmiHost)); // query parameter
            if (rmiPort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "rmiPort", rmiPort)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (subName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_name", subName)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "tag", tag)); // query parameter
            if (trackingId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "trackingId", trackingId)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter
            if (usingSSL != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "usingSSL", usingSSL)); // query parameter
            if (version != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "version", version)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// Search nodes (since 1.3) Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>Task of Node</returns>
        public async System.Threading.Tasks.Task<Node> GetNodesAsync (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null)
        {
             ApiResponse<Node> localVarResponse = await GetNodesAsyncWithHttpInfo(agentVersion, auditEnabled, commonAgentCapabilities, commonAgentOsName, commonAgentOsVersion, commonAgentUuid, commonAgentVersion, customProperty, description, elementCount, eventGeneratorEnabled, eventGeneratorInstalled, hasFailures, icName, id, importedTime, importedTimeRange, ipAddress, isDisabled, isSocksProxy, isSSLSupported, lastCheck, lastRegistration, licensedFeature, macAddress, make, maxSeverity, model, modifiedTime, name, oid, pageLimit, pageStart, proxyHost, proxyPort, realTimeEnabled, rmiHost, rmiPort, subDescription, subName, tag, trackingId, type, usingSSL, version);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search nodes (since 1.3) Returns a list of all nodes or those that match the provided filter criteria. Nodes that the user does not have access to will be omitted from the search results. Filtering for nodes by ip-address only works for agent nodes, because the ip-addresses for other node types are not persisted.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="agentVersion">Agent versions of nodes to fetch. (optional)</param>
        /// <param name="auditEnabled">Audit enabled condition of nodes to fetch. (optional)</param>
        /// <param name="commonAgentCapabilities">Axon agent capabilities of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsName">Axon agent OS names of nodes to fetch. (optional)</param>
        /// <param name="commonAgentOsVersion">Axon agent OS versions of nodes to fetch. (optional)</param>
        /// <param name="commonAgentUuid">Axon agent uuids of nodes to fetch. (optional)</param>
        /// <param name="commonAgentVersion">Axon agent versions of nodes to fetch. (optional)</param>
        /// <param name="customProperty">Custom properties values of nodes to fetch. (optional)</param>
        /// <param name="description">Descriptions of nodes to fetch. (optional)</param>
        /// <param name="elementCount">Element counts of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorEnabled">Event generator enabled condition of nodes to fetch. (optional)</param>
        /// <param name="eventGeneratorInstalled">Event generator installed condition of nodes to fetch. (optional)</param>
        /// <param name="hasFailures">Has failures condition of nodes to fetch. (optional)</param>
        /// <param name="icName">Support for case insensitive search for name parameter. (optional)</param>
        /// <param name="id">IDs of nodes to fetch. (optional)</param>
        /// <param name="importedTime">Imported times of nodes to fetch. (optional)</param>
        /// <param name="importedTimeRange">Imported time range of nodes to fetch (optional)</param>
        /// <param name="ipAddress">IP addresses of nodes to fetch (only finds agent nodes). (optional)</param>
        /// <param name="isDisabled">Is disabled condition of nodes to fetch. (optional)</param>
        /// <param name="isSocksProxy">Is socks proxy condition of nodes to fetch. (optional)</param>
        /// <param name="isSSLSupported">Is SSL supported condition of nodes to fetch. (optional)</param>
        /// <param name="lastCheck">Last checks of nodes to fetch. (optional)</param>
        /// <param name="lastRegistration">Last registration dates of nodes to fetch. (optional)</param>
        /// <param name="licensedFeature">Licensed features of nodes to fetch. (optional)</param>
        /// <param name="macAddress">MAC addresses of nodes to fetch. (optional)</param>
        /// <param name="make">Make of nodes to fetch. (optional)</param>
        /// <param name="maxSeverity">Max severities of nodes to fetch. (optional)</param>
        /// <param name="model">Models of nodes to fetch. (optional)</param>
        /// <param name="modifiedTime">Modified times of nodes to fetch. (optional)</param>
        /// <param name="name">Names of nodes to fetch. (optional)</param>
        /// <param name="oid">Return nodes with the given database object id. (optional)</param>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="proxyHost">Proxy hosts of nodes to fetch. (optional)</param>
        /// <param name="proxyPort">Proxy ports of nodes to fetch. (optional)</param>
        /// <param name="realTimeEnabled">Real time enabled condition of nodes to fetch. (optional)</param>
        /// <param name="rmiHost">RMI hosts of nodes to fetch. (optional)</param>
        /// <param name="rmiPort">RMI ports of nodes to fetch. (optional)</param>
        /// <param name="subDescription">Support for like search for description parameter. (optional)</param>
        /// <param name="subName">Support for like search for name parameter. (optional)</param>
        /// <param name="tag">Tags of nodes to fetch. (optional)</param>
        /// <param name="trackingId">Tracking IDs of nodes to fetch. (optional)</param>
        /// <param name="type">Node type of nodes to fetch. (optional)</param>
        /// <param name="usingSSL">Using SSL condition of nodes to fetch. For Oracle: false -&gt; SECURITY_NONE, true -&gt; SECURITY_ANO_ENCRYPTION and SECURITY_SSL. For SQL Server: false -&gt; SSL_OFF, true -&gt; SSL_REQUEST, SSL_REQUIRE and SSL_AUTHENTICATE. (optional)</param>
        /// <param name="version">Versions of nodes to fetch. (optional)</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Node>> GetNodesAsyncWithHttpInfo (List<string> agentVersion = null, bool? auditEnabled = null, List<string> commonAgentCapabilities = null, List<string> commonAgentOsName = null, List<string> commonAgentOsVersion = null, List<string> commonAgentUuid = null, List<string> commonAgentVersion = null, List<string> customProperty = null, List<string> description = null, List<string> elementCount = null, bool? eventGeneratorEnabled = null, bool? eventGeneratorInstalled = null, bool? hasFailures = null, List<string> icName = null, List<string> id = null, List<string> importedTime = null, string importedTimeRange = null, List<string> ipAddress = null, bool? isDisabled = null, bool? isSocksProxy = null, bool? isSSLSupported = null, List<string> lastCheck = null, List<string> lastRegistration = null, List<string> licensedFeature = null, List<string> macAddress = null, List<string> make = null, List<string> maxSeverity = null, List<string> model = null, List<string> modifiedTime = null, List<string> name = null, List<string> oid = null, string pageLimit = null, string pageStart = null, List<string> proxyHost = null, List<string> proxyPort = null, bool? realTimeEnabled = null, List<string> rmiHost = null, List<string> rmiPort = null, List<string> subDescription = null, List<string> subName = null, List<string> tag = null, List<string> trackingId = null, List<string> type = null, bool? usingSSL = null, List<string> version = null)
        {

            var localVarPath = "/nodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (agentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "agentVersion", agentVersion)); // query parameter
            if (auditEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "auditEnabled", auditEnabled)); // query parameter
            if (commonAgentCapabilities != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentCapabilities", commonAgentCapabilities)); // query parameter
            if (commonAgentOsName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentOsName", commonAgentOsName)); // query parameter
            if (commonAgentOsVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentOsVersion", commonAgentOsVersion)); // query parameter
            if (commonAgentUuid != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentUuid", commonAgentUuid)); // query parameter
            if (commonAgentVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "commonAgentVersion", commonAgentVersion)); // query parameter
            if (customProperty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "customProperty", customProperty)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (elementCount != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "elementCount", elementCount)); // query parameter
            if (eventGeneratorEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "eventGeneratorEnabled", eventGeneratorEnabled)); // query parameter
            if (eventGeneratorInstalled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "eventGeneratorInstalled", eventGeneratorInstalled)); // query parameter
            if (hasFailures != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "hasFailures", hasFailures)); // query parameter
            if (icName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ic_name", icName)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (importedTime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "importedTime", importedTime)); // query parameter
            if (importedTimeRange != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "importedTimeRange", importedTimeRange)); // query parameter
            if (ipAddress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ipAddress", ipAddress)); // query parameter
            if (isDisabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isDisabled", isDisabled)); // query parameter
            if (isSocksProxy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isSocksProxy", isSocksProxy)); // query parameter
            if (isSSLSupported != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "isSSLSupported", isSSLSupported)); // query parameter
            if (lastCheck != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastCheck", lastCheck)); // query parameter
            if (lastRegistration != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastRegistration", lastRegistration)); // query parameter
            if (licensedFeature != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "licensedFeature", licensedFeature)); // query parameter
            if (macAddress != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "macAddress", macAddress)); // query parameter
            if (make != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "make", make)); // query parameter
            if (maxSeverity != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "maxSeverity", maxSeverity)); // query parameter
            if (model != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "model", model)); // query parameter
            if (modifiedTime != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "modifiedTime", modifiedTime)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (oid != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "oid", oid)); // query parameter
            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (proxyHost != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "proxyHost", proxyHost)); // query parameter
            if (proxyPort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "proxyPort", proxyPort)); // query parameter
            if (realTimeEnabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "realTimeEnabled", realTimeEnabled)); // query parameter
            if (rmiHost != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "rmiHost", rmiHost)); // query parameter
            if (rmiPort != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "rmiPort", rmiPort)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (subName != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_name", subName)); // query parameter
            if (tag != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "tag", tag)); // query parameter
            if (trackingId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "trackingId", trackingId)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter
            if (usingSSL != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "usingSSL", usingSSL)); // query parameter
            if (version != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "version", version)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// Get the status of a rule run request (since 1.11) Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>RuleRunRequestCommand</returns>
        public RuleRunRequestCommand GetRuleRunRequestById (string requestId)
        {
             ApiResponse<RuleRunRequestCommand> localVarResponse = GetRuleRunRequestByIdWithHttpInfo(requestId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get the status of a rule run request (since 1.11) Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>ApiResponse of RuleRunRequestCommand</returns>
        public ApiResponse< RuleRunRequestCommand > GetRuleRunRequestByIdWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling NodesApi->GetRuleRunRequestById");

            var localVarPath = "/nodes/ruleRunRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetRuleRunRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RuleRunRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RuleRunRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RuleRunRequestCommand)));
        }

        /// <summary>
        /// Get the status of a rule run request (since 1.11) Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of RuleRunRequestCommand</returns>
        public async System.Threading.Tasks.Task<RuleRunRequestCommand> GetRuleRunRequestByIdAsync (string requestId)
        {
             ApiResponse<RuleRunRequestCommand> localVarResponse = await GetRuleRunRequestByIdAsyncWithHttpInfo(requestId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get the status of a rule run request (since 1.11) Returns the status of a rule run request, including the original request details. If ACL failures occur during processing, the status includes the list of nodes the requesting user did not have permission to scan
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of command to fetch</param>
        /// <returns>Task of ApiResponse (RuleRunRequestCommand)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RuleRunRequestCommand>> GetRuleRunRequestByIdAsyncWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling NodesApi->GetRuleRunRequestById");

            var localVarPath = "/nodes/ruleRunRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetRuleRunRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RuleRunRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RuleRunRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RuleRunRequestCommand)));
        }

        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>NodeRestartResult</returns>
        public NodeRestartResult RestartNodes (NodeRestart body = null)
        {
             ApiResponse<NodeRestartResult> localVarResponse = RestartNodesWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>ApiResponse of NodeRestartResult</returns>
        public ApiResponse< NodeRestartResult > RestartNodesWithHttpInfo (NodeRestart body = null)
        {

            var localVarPath = "/nodes/restart";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RestartNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeRestartResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (NodeRestartResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeRestartResult)));
        }

        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>Task of NodeRestartResult</returns>
        public async System.Threading.Tasks.Task<NodeRestartResult> RestartNodesAsync (NodeRestart body = null)
        {
             ApiResponse<NodeRestartResult> localVarResponse = await RestartNodesAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Restart Agents to bring them back in sync with the TE Server (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">List of IDs of nodes to restart (optional)</param>
        /// <returns>Task of ApiResponse (NodeRestartResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<NodeRestartResult>> RestartNodesAsyncWithHttpInfo (NodeRestart body = null)
        {

            var localVarPath = "/nodes/restart";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RestartNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<NodeRestartResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (NodeRestartResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(NodeRestartResult)));
        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns></returns>
        public void RetireNode (string rkNodeId)
        {
             RetireNodeWithHttpInfo(rkNodeId);
        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RetireNodeWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->RetireNode");

            var localVarPath = "/nodes/{rkNodeId}/retire";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RetireNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RetireNodeAsync (string rkNodeId)
        {
             await RetireNodeAsyncWithHttpInfo(rkNodeId);

        }

        /// <summary>
        /// Retire a node by removing all node licenses allocated to it (since 1.3) Permissions needed: &#39;tool.node.load&#39;
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to retire</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RetireNodeAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->RetireNode");

            var localVarPath = "/nodes/{rkNodeId}/retire";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RetireNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Run rules on nodes (since 1.11) Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>RuleRunRequestCommand</returns>
        public RuleRunRequestCommand RuleRunRequest (RuleRunRequestCommand body)
        {
             ApiResponse<RuleRunRequestCommand> localVarResponse = RuleRunRequestWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Run rules on nodes (since 1.11) Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>ApiResponse of RuleRunRequestCommand</returns>
        public ApiResponse< RuleRunRequestCommand > RuleRunRequestWithHttpInfo (RuleRunRequestCommand body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->RuleRunRequest");

            var localVarPath = "/nodes/ruleRunRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RuleRunRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RuleRunRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RuleRunRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RuleRunRequestCommand)));
        }

        /// <summary>
        /// Run rules on nodes (since 1.11) Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>Task of RuleRunRequestCommand</returns>
        public async System.Threading.Tasks.Task<RuleRunRequestCommand> RuleRunRequestAsync (RuleRunRequestCommand body)
        {
             ApiResponse<RuleRunRequestCommand> localVarResponse = await RuleRunRequestAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Run rules on nodes (since 1.11) Queues a request to run specified set of rules on the given set of nodes. ACL permissions are checked during queue processing
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Rule run creation request to be executed</param>
        /// <returns>Task of ApiResponse (RuleRunRequestCommand)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<RuleRunRequestCommand>> RuleRunRequestAsyncWithHttpInfo (RuleRunRequestCommand body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->RuleRunRequest");

            var localVarPath = "/nodes/ruleRunRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RuleRunRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<RuleRunRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (RuleRunRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(RuleRunRequestCommand)));
        }

        /// <summary>
        /// Set a custom property value for a node (since 1.5) Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns></returns>
        public void SetNodeCustomProperty (string rkNodeId, string propertyName, PropertyValue body)
        {
             SetNodeCustomPropertyWithHttpInfo(rkNodeId, propertyName, body);
        }

        /// <summary>
        /// Set a custom property value for a node (since 1.5) Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> SetNodeCustomPropertyWithHttpInfo (string rkNodeId, string propertyName, PropertyValue body)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->SetNodeCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling NodesApi->SetNodeCustomProperty");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->SetNodeCustomProperty");

            var localVarPath = "/nodes/{rkNodeId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetNodeCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Set a custom property value for a node (since 1.5) Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task SetNodeCustomPropertyAsync (string rkNodeId, string propertyName, PropertyValue body)
        {
             await SetNodeCustomPropertyAsyncWithHttpInfo(rkNodeId, propertyName, body);

        }

        /// <summary>
        /// Set a custom property value for a node (since 1.5) Assign a custom property value to a node. The value must meet the requirements of the specific custom property type. If a the custom property type is already assigned to the node, this will overwrite the existing value.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">Id of the node.</param>
        /// <param name="propertyName">Name of the node custom property type to assign to the node.</param>
        /// <param name="body">Value to assign to the custom property of the node.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> SetNodeCustomPropertyAsyncWithHttpInfo (string rkNodeId, string propertyName, PropertyValue body)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->SetNodeCustomProperty");
            // verify the required parameter 'propertyName' is set
            if (propertyName == null)
                throw new ApiException(400, "Missing required parameter 'propertyName' when calling NodesApi->SetNodeCustomProperty");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->SetNodeCustomProperty");

            var localVarPath = "/nodes/{rkNodeId}/customProperties/{propertyName}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (propertyName != null) localVarPathParams.Add("propertyName", this.Configuration.ApiClient.ParameterToString(propertyName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetNodeCustomProperty", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4) Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns></returns>
        public void UnregisterCommonAgent (string rkNodeId)
        {
             UnregisterCommonAgentWithHttpInfo(rkNodeId);
        }

        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4) Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UnregisterCommonAgentWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->UnregisterCommonAgent");

            var localVarPath = "/nodes/{rkNodeId}/unregisterCommonAgent";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UnregisterCommonAgent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4) Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UnregisterCommonAgentAsync (string rkNodeId)
        {
             await UnregisterCommonAgentAsyncWithHttpInfo(rkNodeId);

        }

        /// <summary>
        /// Unregister an Axon agent from the server node (since 1.4) Clears all Axon agent registration data attached to the server node. All subsequent usage of the node will attempt to interact with the Java based agent.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of the node</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UnregisterCommonAgentAsyncWithHttpInfo (string rkNodeId)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->UnregisterCommonAgent");

            var localVarPath = "/nodes/{rkNodeId}/unregisterCommonAgent";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UnregisterCommonAgent", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Update an existing node custom property type (since 1.6) Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>CustomPropertyType</returns>
        public CustomPropertyType UpdateCustomPropertyType (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = UpdateCustomPropertyTypeWithHttpInfo(body, rkCustomPropertyTypeId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an existing node custom property type (since 1.6) Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>ApiResponse of CustomPropertyType</returns>
        public ApiResponse< CustomPropertyType > UpdateCustomPropertyTypeWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->UpdateCustomPropertyType");
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling NodesApi->UpdateCustomPropertyType");

            var localVarPath = "/nodes/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Update an existing node custom property type (since 1.6) Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of CustomPropertyType</returns>
        public async System.Threading.Tasks.Task<CustomPropertyType> UpdateCustomPropertyTypeAsync (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
             ApiResponse<CustomPropertyType> localVarResponse = await UpdateCustomPropertyTypeAsyncWithHttpInfo(body, rkCustomPropertyTypeId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an existing node custom property type (since 1.6) Modifies a node custom property type to update the submitted fields with new values. The &#39;id&#39; and &#39;type&#39; fields can not be updated.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Custom property type to be updated</param>
        /// <param name="rkCustomPropertyTypeId">Id of custom property type to update</param>
        /// <returns>Task of ApiResponse (CustomPropertyType)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CustomPropertyType>> UpdateCustomPropertyTypeAsyncWithHttpInfo (CustomPropertyType body, string rkCustomPropertyTypeId)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->UpdateCustomPropertyType");
            // verify the required parameter 'rkCustomPropertyTypeId' is set
            if (rkCustomPropertyTypeId == null)
                throw new ApiException(400, "Missing required parameter 'rkCustomPropertyTypeId' when calling NodesApi->UpdateCustomPropertyType");

            var localVarPath = "/nodes/customPropertyTypes/{rkCustomPropertyTypeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkCustomPropertyTypeId != null) localVarPathParams.Add("rkCustomPropertyTypeId", this.Configuration.ApiClient.ParameterToString(rkCustomPropertyTypeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCustomPropertyType", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CustomPropertyType>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CustomPropertyType) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CustomPropertyType)));
        }

        /// <summary>
        /// Update a node (since 1.4) Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>Node</returns>
        public Node UpdateNode (string rkNodeId, Node body)
        {
             ApiResponse<Node> localVarResponse = UpdateNodeWithHttpInfo(rkNodeId, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update a node (since 1.4) Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>ApiResponse of Node</returns>
        public ApiResponse< Node > UpdateNodeWithHttpInfo (string rkNodeId, Node body)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->UpdateNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->UpdateNode");

            var localVarPath = "/nodes/{rkNodeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

        /// <summary>
        /// Update a node (since 1.4) Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>Task of Node</returns>
        public async System.Threading.Tasks.Task<Node> UpdateNodeAsync (string rkNodeId, Node body)
        {
             ApiResponse<Node> localVarResponse = await UpdateNodeAsyncWithHttpInfo(rkNodeId, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update a node (since 1.4) Modifies a node updating the provided fields with new values. Read-only fields are ignored.&lt;br /&gt;Licenses are restricted by node type, and can be applied as follows:&lt;br /&gt; * Agents:    * FSI    * FSI-Policy    * FSI-Remediation  * Database Servers:   * DBI   * DBI-Policy * Directory Servers:   * DSI   * DSI-Policy * Network Devices:   * TWRouter   * TWRouter-Policy * VMWare:   * VMWare-ESX   * VMWare-ESX-Policy &lt;br /&gt;&lt;br /&gt; See endpoint GET /api/v1/settings/licenses for a listing of feature names to product display names.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkNodeId">ID of node to be updated</param>
        /// <param name="body">Node description to update the existing node</param>
        /// <returns>Task of ApiResponse (Node)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Node>> UpdateNodeAsyncWithHttpInfo (string rkNodeId, Node body)
        {
            // verify the required parameter 'rkNodeId' is set
            if (rkNodeId == null)
                throw new ApiException(400, "Missing required parameter 'rkNodeId' when calling NodesApi->UpdateNode");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling NodesApi->UpdateNode");

            var localVarPath = "/nodes/{rkNodeId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "text/plain"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkNodeId != null) localVarPathParams.Add("rkNodeId", this.Configuration.ApiClient.ParameterToString(rkNodeId)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateNode", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Node>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Node) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Node)));
        }

    }
}
