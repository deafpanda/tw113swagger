/* 
 * Tripwire Enterprise TE REST API User Guide & Reference
 *
 * The TE REST API allows automation of many aspects of Tripwire Enterprise
 *
 * OpenAPI spec version: 1.12.1.bmaster.r20170922182356-4e84151.b1741
 * Contact: support@tripwire.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface ITasksApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Post a request to execute a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>ExecuteTaskRequestCommand</returns>
        ExecuteTaskRequestCommand CreateExecuteTaskRequest (ExecuteTaskRequestCommand body);

        /// <summary>
        /// Post a request to execute a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>ApiResponse of ExecuteTaskRequestCommand</returns>
        ApiResponse<ExecuteTaskRequestCommand> CreateExecuteTaskRequestWithHttpInfo (ExecuteTaskRequestCommand body);
        /// <summary>
        /// Post a new task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>Task</returns>
        Task CreateTask (Task body);

        /// <summary>
        /// Post a new task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>ApiResponse of Task</returns>
        ApiResponse<Task> CreateTaskWithHttpInfo (Task body);
        /// <summary>
        /// Delete a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns></returns>
        void DeleteTask (string rkTaskId);

        /// <summary>
        /// Delete a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteTaskWithHttpInfo (string rkTaskId);
        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single Task Execution Request
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>ExecuteTaskRequestCommand</returns>
        ExecuteTaskRequestCommand GetExecutionTaskRequestById (string requestId);

        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single Task Execution Request
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>ApiResponse of ExecuteTaskRequestCommand</returns>
        ApiResponse<ExecuteTaskRequestCommand> GetExecutionTaskRequestByIdWithHttpInfo (string requestId);
        /// <summary>
        /// Get nodes targeted by this task (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>List&lt;Node&gt;</returns>
        List<Node> GetTargetableNodes (string rkTaskId);

        /// <summary>
        /// Get nodes targeted by this task (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>ApiResponse of List&lt;Node&gt;</returns>
        ApiResponse<List<Node>> GetTargetableNodesWithHttpInfo (string rkTaskId);
        /// <summary>
        /// Get task details by ID
        /// </summary>
        /// <remarks>
        /// Returns the details of a single task
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task</returns>
        Task GetTaskById (string rkTaskId);

        /// <summary>
        /// Get task details by ID
        /// </summary>
        /// <remarks>
        /// Returns the details of a single task
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>ApiResponse of Task</returns>
        ApiResponse<Task> GetTaskByIdWithHttpInfo (string rkTaskId);
        /// <summary>
        /// Get a list of tasks (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>Task</returns>
        Task GetTasks (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null);

        /// <summary>
        /// Get a list of tasks (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>ApiResponse of Task</returns>
        ApiResponse<Task> GetTasksWithHttpInfo (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null);
        /// <summary>
        /// Put an update to an existing task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>Task</returns>
        Task UpdateTask (string rkTaskId, Task task);

        /// <summary>
        /// Put an update to an existing task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>ApiResponse of Task</returns>
        ApiResponse<Task> UpdateTaskWithHttpInfo (string rkTaskId, Task task);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Post a request to execute a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>Task of ExecuteTaskRequestCommand</returns>
        System.Threading.Tasks.Task<ExecuteTaskRequestCommand> CreateExecuteTaskRequestAsync (ExecuteTaskRequestCommand body);

        /// <summary>
        /// Post a request to execute a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>Task of ApiResponse (ExecuteTaskRequestCommand)</returns>
        System.Threading.Tasks.Task<ApiResponse<ExecuteTaskRequestCommand>> CreateExecuteTaskRequestAsyncWithHttpInfo (ExecuteTaskRequestCommand body);
        /// <summary>
        /// Post a new task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>Task of Task</returns>
        System.Threading.Tasks.Task<Task> CreateTaskAsync (Task body);

        /// <summary>
        /// Post a new task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        System.Threading.Tasks.Task<ApiResponse<Task>> CreateTaskAsyncWithHttpInfo (Task body);
        /// <summary>
        /// Delete a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteTaskAsync (string rkTaskId);

        /// <summary>
        /// Delete a task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteTaskAsyncWithHttpInfo (string rkTaskId);
        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single Task Execution Request
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>Task of ExecuteTaskRequestCommand</returns>
        System.Threading.Tasks.Task<ExecuteTaskRequestCommand> GetExecutionTaskRequestByIdAsync (string requestId);

        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns the details of a single Task Execution Request
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>Task of ApiResponse (ExecuteTaskRequestCommand)</returns>
        System.Threading.Tasks.Task<ApiResponse<ExecuteTaskRequestCommand>> GetExecutionTaskRequestByIdAsyncWithHttpInfo (string requestId);
        /// <summary>
        /// Get nodes targeted by this task (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of List&lt;Node&gt;</returns>
        System.Threading.Tasks.Task<List<Node>> GetTargetableNodesAsync (string rkTaskId);

        /// <summary>
        /// Get nodes targeted by this task (since 1.11)
        /// </summary>
        /// <remarks>
        /// Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of ApiResponse (List&lt;Node&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<Node>>> GetTargetableNodesAsyncWithHttpInfo (string rkTaskId);
        /// <summary>
        /// Get task details by ID
        /// </summary>
        /// <remarks>
        /// Returns the details of a single task
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of Task</returns>
        System.Threading.Tasks.Task<Task> GetTaskByIdAsync (string rkTaskId);

        /// <summary>
        /// Get task details by ID
        /// </summary>
        /// <remarks>
        /// Returns the details of a single task
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        System.Threading.Tasks.Task<ApiResponse<Task>> GetTaskByIdAsyncWithHttpInfo (string rkTaskId);
        /// <summary>
        /// Get a list of tasks (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>Task of Task</returns>
        System.Threading.Tasks.Task<Task> GetTasksAsync (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null);

        /// <summary>
        /// Get a list of tasks (since 1.6)
        /// </summary>
        /// <remarks>
        /// Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        System.Threading.Tasks.Task<ApiResponse<Task>> GetTasksAsyncWithHttpInfo (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null);
        /// <summary>
        /// Put an update to an existing task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>Task of Task</returns>
        System.Threading.Tasks.Task<Task> UpdateTaskAsync (string rkTaskId, Task task);

        /// <summary>
        /// Put an update to an existing task (since 1.6)
        /// </summary>
        /// <remarks>
        /// Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        System.Threading.Tasks.Task<ApiResponse<Task>> UpdateTaskAsyncWithHttpInfo (string rkTaskId, Task task);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class TasksApi : ITasksApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="TasksApi"/> class.
        /// </summary>
        /// <returns></returns>
        public TasksApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="TasksApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public TasksApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Post a request to execute a task (since 1.6) Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>ExecuteTaskRequestCommand</returns>
        public ExecuteTaskRequestCommand CreateExecuteTaskRequest (ExecuteTaskRequestCommand body)
        {
             ApiResponse<ExecuteTaskRequestCommand> localVarResponse = CreateExecuteTaskRequestWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Post a request to execute a task (since 1.6) Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>ApiResponse of ExecuteTaskRequestCommand</returns>
        public ApiResponse< ExecuteTaskRequestCommand > CreateExecuteTaskRequestWithHttpInfo (ExecuteTaskRequestCommand body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling TasksApi->CreateExecuteTaskRequest");

            var localVarPath = "/tasks/executeTaskRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateExecuteTaskRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ExecuteTaskRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ExecuteTaskRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ExecuteTaskRequestCommand)));
        }

        /// <summary>
        /// Post a request to execute a task (since 1.6) Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>Task of ExecuteTaskRequestCommand</returns>
        public async System.Threading.Tasks.Task<ExecuteTaskRequestCommand> CreateExecuteTaskRequestAsync (ExecuteTaskRequestCommand body)
        {
             ApiResponse<ExecuteTaskRequestCommand> localVarResponse = await CreateExecuteTaskRequestAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Post a request to execute a task (since 1.6) Request to run a task. The task must be idle or the request will be rejected. Status of the request may be checked with a call to GET /api/v1/tasks/executeTaskRequests/{requestId} using the ID returned.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">A request for to perform the execution of a Task</param>
        /// <returns>Task of ApiResponse (ExecuteTaskRequestCommand)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ExecuteTaskRequestCommand>> CreateExecuteTaskRequestAsyncWithHttpInfo (ExecuteTaskRequestCommand body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling TasksApi->CreateExecuteTaskRequest");

            var localVarPath = "/tasks/executeTaskRequests";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateExecuteTaskRequest", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ExecuteTaskRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ExecuteTaskRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ExecuteTaskRequestCommand)));
        }

        /// <summary>
        /// Post a new task (since 1.6) Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>Task</returns>
        public Task CreateTask (Task body)
        {
             ApiResponse<Task> localVarResponse = CreateTaskWithHttpInfo(body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Post a new task (since 1.6) Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>ApiResponse of Task</returns>
        public ApiResponse< Task > CreateTaskWithHttpInfo (Task body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling TasksApi->CreateTask");

            var localVarPath = "/tasks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateTask", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Post a new task (since 1.6) Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>Task of Task</returns>
        public async System.Threading.Tasks.Task<Task> CreateTaskAsync (Task body)
        {
             ApiResponse<Task> localVarResponse = await CreateTaskAsyncWithHttpInfo(body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Post a new task (since 1.6) Creates a new task in the root task group. 3 task types can be created: Check Rule Task, Baseline Rule Task, and Report Task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Task to be created in TE</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Task>> CreateTaskAsyncWithHttpInfo (Task body)
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling TasksApi->CreateTask");

            var localVarPath = "/tasks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateTask", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Delete a task (since 1.6) Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns></returns>
        public void DeleteTask (string rkTaskId)
        {
             DeleteTaskWithHttpInfo(rkTaskId);
        }

        /// <summary>
        /// Delete a task (since 1.6) Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteTaskWithHttpInfo (string rkTaskId)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->DeleteTask");

            var localVarPath = "/tasks/{rkTaskId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteTask", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a task (since 1.6) Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteTaskAsync (string rkTaskId)
        {
             await DeleteTaskAsyncWithHttpInfo(rkTaskId);

        }

        /// <summary>
        /// Delete a task (since 1.6) Remove a task from the TE system. The task must be idle at the time of deletion.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to delete</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteTaskAsyncWithHttpInfo (string rkTaskId)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->DeleteTask");

            var localVarPath = "/tasks/{rkTaskId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteTask", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6) Returns the details of a single Task Execution Request
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>ExecuteTaskRequestCommand</returns>
        public ExecuteTaskRequestCommand GetExecutionTaskRequestById (string requestId)
        {
             ApiResponse<ExecuteTaskRequestCommand> localVarResponse = GetExecutionTaskRequestByIdWithHttpInfo(requestId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6) Returns the details of a single Task Execution Request
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>ApiResponse of ExecuteTaskRequestCommand</returns>
        public ApiResponse< ExecuteTaskRequestCommand > GetExecutionTaskRequestByIdWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling TasksApi->GetExecutionTaskRequestById");

            var localVarPath = "/tasks/executeTaskRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetExecutionTaskRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ExecuteTaskRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ExecuteTaskRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ExecuteTaskRequestCommand)));
        }

        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6) Returns the details of a single Task Execution Request
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>Task of ExecuteTaskRequestCommand</returns>
        public async System.Threading.Tasks.Task<ExecuteTaskRequestCommand> GetExecutionTaskRequestByIdAsync (string requestId)
        {
             ApiResponse<ExecuteTaskRequestCommand> localVarResponse = await GetExecutionTaskRequestByIdAsyncWithHttpInfo(requestId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Task Execution Request details by ID (since 1.6) Returns the details of a single Task Execution Request
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="requestId">ID of Task Execution Request to get</param>
        /// <returns>Task of ApiResponse (ExecuteTaskRequestCommand)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ExecuteTaskRequestCommand>> GetExecutionTaskRequestByIdAsyncWithHttpInfo (string requestId)
        {
            // verify the required parameter 'requestId' is set
            if (requestId == null)
                throw new ApiException(400, "Missing required parameter 'requestId' when calling TasksApi->GetExecutionTaskRequestById");

            var localVarPath = "/tasks/executeTaskRequests/{requestId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (requestId != null) localVarPathParams.Add("requestId", this.Configuration.ApiClient.ParameterToString(requestId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetExecutionTaskRequestById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ExecuteTaskRequestCommand>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ExecuteTaskRequestCommand) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ExecuteTaskRequestCommand)));
        }

        /// <summary>
        /// Get nodes targeted by this task (since 1.11) Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>List&lt;Node&gt;</returns>
        public List<Node> GetTargetableNodes (string rkTaskId)
        {
             ApiResponse<List<Node>> localVarResponse = GetTargetableNodesWithHttpInfo(rkTaskId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get nodes targeted by this task (since 1.11) Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>ApiResponse of List&lt;Node&gt;</returns>
        public ApiResponse< List<Node> > GetTargetableNodesWithHttpInfo (string rkTaskId)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->GetTargetableNodes");

            var localVarPath = "/tasks/{rkTaskId}/targetableNodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetTargetableNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Node>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<Node>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Node>)));
        }

        /// <summary>
        /// Get nodes targeted by this task (since 1.11) Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of List&lt;Node&gt;</returns>
        public async System.Threading.Tasks.Task<List<Node>> GetTargetableNodesAsync (string rkTaskId)
        {
             ApiResponse<List<Node>> localVarResponse = await GetTargetableNodesAsyncWithHttpInfo(rkTaskId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get nodes targeted by this task (since 1.11) Returns nodes scoped to this task that at least one rule in the task is able to target
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of ApiResponse (List&lt;Node&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<Node>>> GetTargetableNodesAsyncWithHttpInfo (string rkTaskId)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->GetTargetableNodes");

            var localVarPath = "/tasks/{rkTaskId}/targetableNodes";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetTargetableNodes", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<Node>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<Node>) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<Node>)));
        }

        /// <summary>
        /// Get task details by ID Returns the details of a single task
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task</returns>
        public Task GetTaskById (string rkTaskId)
        {
             ApiResponse<Task> localVarResponse = GetTaskByIdWithHttpInfo(rkTaskId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get task details by ID Returns the details of a single task
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>ApiResponse of Task</returns>
        public ApiResponse< Task > GetTaskByIdWithHttpInfo (string rkTaskId)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->GetTaskById");

            var localVarPath = "/tasks/{rkTaskId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetTaskById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Get task details by ID Returns the details of a single task
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of Task</returns>
        public async System.Threading.Tasks.Task<Task> GetTaskByIdAsync (string rkTaskId)
        {
             ApiResponse<Task> localVarResponse = await GetTaskByIdAsyncWithHttpInfo(rkTaskId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get task details by ID Returns the details of a single task
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to get</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Task>> GetTaskByIdAsyncWithHttpInfo (string rkTaskId)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->GetTaskById");

            var localVarPath = "/tasks/{rkTaskId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetTaskById", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Get a list of tasks (since 1.6) Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>Task</returns>
        public Task GetTasks (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null)
        {
             ApiResponse<Task> localVarResponse = GetTasksWithHttpInfo(pageLimit, pageStart, id, name, type, description, subDescription, status, enabled, lastStart, lastDuration, nextStart, userId, archiveLogsOlderThan, archiveLogsExceeding, timeout, compactVersionsOlderThan, compactVersionsExceeding, archiveAuditEvents, newBaselinesOnly, nodeId, ruleId, actionIds, reportId, reportUserIds, additionalEmailAddresses, emailServer, reportFormat, archiveReports, ignoreEmptyReports);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a list of tasks (since 1.6) Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>ApiResponse of Task</returns>
        public ApiResponse< Task > GetTasksWithHttpInfo (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null)
        {

            var localVarPath = "/tasks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "status", status)); // query parameter
            if (enabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "enabled", enabled)); // query parameter
            if (lastStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastStart", lastStart)); // query parameter
            if (lastDuration != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastDuration", lastDuration)); // query parameter
            if (nextStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nextStart", nextStart)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "userId", userId)); // query parameter
            if (archiveLogsOlderThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "archiveLogsOlderThan", archiveLogsOlderThan)); // query parameter
            if (archiveLogsExceeding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "archiveLogsExceeding", archiveLogsExceeding)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeout", timeout)); // query parameter
            if (compactVersionsOlderThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "compactVersionsOlderThan", compactVersionsOlderThan)); // query parameter
            if (compactVersionsExceeding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "compactVersionsExceeding", compactVersionsExceeding)); // query parameter
            if (archiveAuditEvents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "archiveAuditEvents", archiveAuditEvents)); // query parameter
            if (newBaselinesOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "newBaselinesOnly", newBaselinesOnly)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeId", nodeId)); // query parameter
            if (ruleId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleId", ruleId)); // query parameter
            if (actionIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "actionIds", actionIds)); // query parameter
            if (reportId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "reportId", reportId)); // query parameter
            if (reportUserIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "reportUserIds", reportUserIds)); // query parameter
            if (additionalEmailAddresses != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "additionalEmailAddresses", additionalEmailAddresses)); // query parameter
            if (emailServer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "emailServer", emailServer)); // query parameter
            if (reportFormat != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "reportFormat", reportFormat)); // query parameter
            if (archiveReports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "archiveReports", archiveReports)); // query parameter
            if (ignoreEmptyReports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ignoreEmptyReports", ignoreEmptyReports)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetTasks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Get a list of tasks (since 1.6) Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>Task of Task</returns>
        public async System.Threading.Tasks.Task<Task> GetTasksAsync (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null)
        {
             ApiResponse<Task> localVarResponse = await GetTasksAsyncWithHttpInfo(pageLimit, pageStart, id, name, type, description, subDescription, status, enabled, lastStart, lastDuration, nextStart, userId, archiveLogsOlderThan, archiveLogsExceeding, timeout, compactVersionsOlderThan, compactVersionsExceeding, archiveAuditEvents, newBaselinesOnly, nodeId, ruleId, actionIds, reportId, reportUserIds, additionalEmailAddresses, emailServer, reportFormat, archiveReports, ignoreEmptyReports);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a list of tasks (since 1.6) Returns a list of all tasks, or only those tasks that match the provided filter criteria. Search filters are supported for all fields except schedule. The task list is returned ordered by name.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pageLimit">Page limit for paging support (optional)</param>
        /// <param name="pageStart">Page start for paging support (optional)</param>
        /// <param name="id">Ids of tasks to fetch (optional)</param>
        /// <param name="name">Name of tasks to fetch (optional)</param>
        /// <param name="type">Type of tasks to fetch (optional)</param>
        /// <param name="description">Description of tasks to fetch (optional)</param>
        /// <param name="subDescription">Substring matching for description of tasks to fetch (optional)</param>
        /// <param name="status">Statuses of tasks to fetch (optional)</param>
        /// <param name="enabled">Fetch only tasks that are enabled or disabled (optional)</param>
        /// <param name="lastStart">Last start of execution of tasks to fetch (optional)</param>
        /// <param name="lastDuration">Last duration of execution of tasks to fetch (optional)</param>
        /// <param name="nextStart">Next start for execution of tasks to fetch (optional)</param>
        /// <param name="userId">Ids of users of tasks to fetch (optional)</param>
        /// <param name="archiveLogsOlderThan">Number of days to retain latests logs of tasks to fetch (optional)</param>
        /// <param name="archiveLogsExceeding">Number of maximum log messages to retain of tasks to fetch (optional)</param>
        /// <param name="timeout">Hour timeout of tasks to fetch (optional)</param>
        /// <param name="compactVersionsOlderThan">Days to ratain element versions of tasks to fetch (optional)</param>
        /// <param name="compactVersionsExceeding">Maximum latests element versions to reatain of tasks to fetch (optional)</param>
        /// <param name="archiveAuditEvents">Audit events exceeding retention age option of tasks to fetch (optional)</param>
        /// <param name="newBaselinesOnly">New baseline element versions creation restriction option of tasks to fetch (optional)</param>
        /// <param name="nodeId">Node or node group ids in scope of tasks to fetch (optional)</param>
        /// <param name="ruleId">Rule or rule group ids in scope of tasks to fetch (optional)</param>
        /// <param name="actionIds">Ids of actions to execute for tasks to fetch (optional)</param>
        /// <param name="reportId">Ids of reports to execute for tasks to fetch (optional)</param>
        /// <param name="reportUserIds">Ids of users who will receive reports from tasks to fetch (optional)</param>
        /// <param name="additionalEmailAddresses">Email addresses that will receive reports from tasks to fetch (optional)</param>
        /// <param name="emailServer">Name of email server for sending reports from tasks to fetch (optional)</param>
        /// <param name="reportFormat">Report format used for tasks to fetch (optional)</param>
        /// <param name="archiveReports">Archive report option of tasks to fetch (optional)</param>
        /// <param name="ignoreEmptyReports">Ignore empty reports option of tasks to fetch (optional)</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Task>> GetTasksAsyncWithHttpInfo (string pageLimit = null, string pageStart = null, List<string> id = null, List<string> name = null, List<string> type = null, List<string> description = null, List<string> subDescription = null, List<string> status = null, bool? enabled = null, List<string> lastStart = null, List<string> lastDuration = null, List<string> nextStart = null, List<string> userId = null, List<string> archiveLogsOlderThan = null, List<string> archiveLogsExceeding = null, List<string> timeout = null, List<string> compactVersionsOlderThan = null, List<string> compactVersionsExceeding = null, bool? archiveAuditEvents = null, bool? newBaselinesOnly = null, List<string> nodeId = null, List<string> ruleId = null, List<string> actionIds = null, List<string> reportId = null, List<string> reportUserIds = null, List<string> additionalEmailAddresses = null, List<string> emailServer = null, List<string> reportFormat = null, bool? archiveReports = null, bool? ignoreEmptyReports = null)
        {

            var localVarPath = "/tasks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pageLimit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageLimit", pageLimit)); // query parameter
            if (pageStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pageStart", pageStart)); // query parameter
            if (id != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "id", id)); // query parameter
            if (name != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "name", name)); // query parameter
            if (type != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "type", type)); // query parameter
            if (description != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "description", description)); // query parameter
            if (subDescription != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "sub_description", subDescription)); // query parameter
            if (status != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "status", status)); // query parameter
            if (enabled != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "enabled", enabled)); // query parameter
            if (lastStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastStart", lastStart)); // query parameter
            if (lastDuration != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "lastDuration", lastDuration)); // query parameter
            if (nextStart != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nextStart", nextStart)); // query parameter
            if (userId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "userId", userId)); // query parameter
            if (archiveLogsOlderThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "archiveLogsOlderThan", archiveLogsOlderThan)); // query parameter
            if (archiveLogsExceeding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "archiveLogsExceeding", archiveLogsExceeding)); // query parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "timeout", timeout)); // query parameter
            if (compactVersionsOlderThan != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "compactVersionsOlderThan", compactVersionsOlderThan)); // query parameter
            if (compactVersionsExceeding != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "compactVersionsExceeding", compactVersionsExceeding)); // query parameter
            if (archiveAuditEvents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "archiveAuditEvents", archiveAuditEvents)); // query parameter
            if (newBaselinesOnly != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "newBaselinesOnly", newBaselinesOnly)); // query parameter
            if (nodeId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "nodeId", nodeId)); // query parameter
            if (ruleId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "ruleId", ruleId)); // query parameter
            if (actionIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "actionIds", actionIds)); // query parameter
            if (reportId != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "reportId", reportId)); // query parameter
            if (reportUserIds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "reportUserIds", reportUserIds)); // query parameter
            if (additionalEmailAddresses != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "additionalEmailAddresses", additionalEmailAddresses)); // query parameter
            if (emailServer != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "emailServer", emailServer)); // query parameter
            if (reportFormat != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "reportFormat", reportFormat)); // query parameter
            if (archiveReports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "archiveReports", archiveReports)); // query parameter
            if (ignoreEmptyReports != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ignoreEmptyReports", ignoreEmptyReports)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetTasks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Put an update to an existing task (since 1.6) Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>Task</returns>
        public Task UpdateTask (string rkTaskId, Task task)
        {
             ApiResponse<Task> localVarResponse = UpdateTaskWithHttpInfo(rkTaskId, task);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Put an update to an existing task (since 1.6) Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>ApiResponse of Task</returns>
        public ApiResponse< Task > UpdateTaskWithHttpInfo (string rkTaskId, Task task)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->UpdateTask");
            // verify the required parameter 'task' is set
            if (task == null)
                throw new ApiException(400, "Missing required parameter 'task' when calling TasksApi->UpdateTask");

            var localVarPath = "/tasks/{rkTaskId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter
            if (task != null && task.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(task); // http body (model) parameter
            }
            else
            {
                localVarPostBody = task; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateTask", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

        /// <summary>
        /// Put an update to an existing task (since 1.6) Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>Task of Task</returns>
        public async System.Threading.Tasks.Task<Task> UpdateTaskAsync (string rkTaskId, Task task)
        {
             ApiResponse<Task> localVarResponse = await UpdateTaskAsyncWithHttpInfo(rkTaskId, task);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Put an update to an existing task (since 1.6) Updates an existing task, ignoring the following read-only fields: type, status, lastStart, lastDuration, and nextStart. You may not rename to the same name as another task.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="rkTaskId">ID of Task to be updated</param>
        /// <param name="task">Task description to update the existing task</param>
        /// <returns>Task of ApiResponse (Task)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Task>> UpdateTaskAsyncWithHttpInfo (string rkTaskId, Task task)
        {
            // verify the required parameter 'rkTaskId' is set
            if (rkTaskId == null)
                throw new ApiException(400, "Missing required parameter 'rkTaskId' when calling TasksApi->UpdateTask");
            // verify the required parameter 'task' is set
            if (task == null)
                throw new ApiException(400, "Missing required parameter 'task' when calling TasksApi->UpdateTask");

            var localVarPath = "/tasks/{rkTaskId}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (rkTaskId != null) localVarPathParams.Add("rkTaskId", this.Configuration.ApiClient.ParameterToString(rkTaskId)); // path parameter
            if (task != null && task.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(task); // http body (model) parameter
            }
            else
            {
                localVarPostBody = task; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateTask", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Task>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Task) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(Task)));
        }

    }
}
